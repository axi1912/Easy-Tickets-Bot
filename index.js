const { Client, GatewayIntentBits, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ModalBuilder, TextInputBuilder, TextInputStyle, PermissionFlagsBits, REST, Routes, StringSelectMenuBuilder } = require('discord.js');
const fs = require('fs');
require('dotenv').config();

const client = new Client({
  intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages, GatewayIntentBits.MessageContent]
});

// Archivo de tickets
const TICKETS_FILE = './tickets.json';
const CANAL_LOGS = '1419826668708827146';

// Archivo de econom√≠a
const ECONOMY_FILE = './economy.json';

// Almacenar juegos activos en memoria
const activeGames = new Map();

// Sistema de Backup Autom√°tico
function createBackup() {
  try {
    const backupDir = './backups';
    if (!fs.existsSync(backupDir)) {
      fs.mkdirSync(backupDir);
    }

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    
    // Backup de econom√≠a
    if (fs.existsSync(ECONOMY_FILE)) {
      const economyBackup = `${backupDir}/economy_${timestamp}.json`;
      fs.copyFileSync(ECONOMY_FILE, economyBackup);
    }

    // Backup de tickets
    if (fs.existsSync(TICKETS_FILE)) {
      const ticketsBackup = `${backupDir}/tickets_${timestamp}.json`;
      fs.copyFileSync(TICKETS_FILE, ticketsBackup);
    }

    // Limpiar backups antiguos (mantener solo los √∫ltimos 10 de cada tipo)
    const files = fs.readdirSync(backupDir);
    const economyBackups = files.filter(f => f.startsWith('economy_')).sort().reverse();
    const ticketsBackups = files.filter(f => f.startsWith('tickets_')).sort().reverse();

    economyBackups.slice(10).forEach(file => fs.unlinkSync(`${backupDir}/${file}`));
    ticketsBackups.slice(10).forEach(file => fs.unlinkSync(`${backupDir}/${file}`));

    console.log(`‚úÖ Backup creado: ${timestamp}`);
  } catch (error) {
    console.error('‚ùå Error creando backup:', error);
  }
}

// Funci√≥n para obtener los roles de staff (soporta m√∫ltiples roles separados por comas)
function getStaffRoles() {
  const staffRoles = process.env.ROL_STAFF || '1241211764100698203'; // Rol por defecto si no est√° configurado
  return staffRoles.split(',').map(id => id.trim());
}

// Cargar/guardar tickets
function loadTickets() {
  if (!fs.existsSync(TICKETS_FILE)) return {};
  return JSON.parse(fs.readFileSync(TICKETS_FILE, 'utf8'));
}

function saveTickets(tickets) {
  fs.writeFileSync(TICKETS_FILE, JSON.stringify(tickets, null, 2));
}

// Cargar/guardar econom√≠a
function loadEconomy() {
  if (!fs.existsSync(ECONOMY_FILE)) return {};
  return JSON.parse(fs.readFileSync(ECONOMY_FILE, 'utf8'));
}

function saveEconomy(economy) {
  fs.writeFileSync(ECONOMY_FILE, JSON.stringify(economy, null, 2));
}

// Generar misiones diarias aleatorias
function generateDailyQuests() {
  const possibleQuests = [
    { id: 'play_games', description: 'Juega 3 partidas en el casino', reward: 150, goal: 3, progress: 0 },
    { id: 'win_games', description: 'Gana 2 partidas', reward: 200, goal: 2, progress: 0 },
    { id: 'work', description: 'Trabaja 2 veces', reward: 100, goal: 2, progress: 0 },
    { id: 'transfer', description: 'Transfiere monedas a otro usuario', reward: 120, goal: 1, progress: 0 },
    { id: 'daily', description: 'Reclama tu daily', reward: 80, goal: 1, progress: 0 },
    { id: 'spend', description: 'Gasta 500 monedas', reward: 180, goal: 500, progress: 0 },
    { id: 'duel', description: 'Participa en un duelo', reward: 150, goal: 1, progress: 0 }
  ];

  // Seleccionar 3 misiones aleatorias
  const shuffled = possibleQuests.sort(() => Math.random() - 0.5);
  return shuffled.slice(0, 3).map((q, i) => ({ ...q, id: `quest_${i}` }));
}

// Sistema de trabajos - Datos de trabajos
function getJobsData(workLevel) {
  const baseJobs = [
    {
      id: 'programmer',
      name: 'Programador',
      emoji: 'üíª',
      unlockLevel: 1,
      questions: [
        { q: 'üêõ ¬øQu√© es un "null pointer exception"?', a: ['Variable sin valor asignado', 'Error de sintaxis', 'Problema de red'], correct: 0 },
        { q: 'üìö ¬øQu√© es un array?', a: ['Una lista de elementos', 'Un n√∫mero', 'Una funci√≥n'], correct: 0 },
        { q: 'üîÑ ¬øQu√© hace un loop?', a: ['Repite c√≥digo', 'Borra datos', 'Cierra programa'], correct: 0 },
        { q: '‚ö° ¬øQu√© lenguaje usa Node.js?', a: ['JavaScript', 'Python', 'Java'], correct: 0 },
        { q: 'üéØ ¬øQu√© es debugging?', a: ['Encontrar y arreglar errores', 'Escribir c√≥digo', 'Borrar archivos'], correct: 0 }
      ]
    },
    {
      id: 'chef',
      name: 'Chef',
      emoji: 'üë®‚Äçüç≥',
      unlockLevel: 1,
      questions: [
        { q: 'üå°Ô∏è ¬øA qu√© temperatura hierve el agua?', a: ['100¬∞C', '50¬∞C', '200¬∞C'], correct: 0 },
        { q: 'üç≥ ¬øCu√°l es el primer paso para hacer un huevo frito?', a: ['Calentar la sart√©n', 'Agregar sal', 'Batir el huevo'], correct: 0 },
        { q: 'ü•ñ ¬øQu√© ingrediente b√°sico se usa para hacer pan?', a: ['Harina', 'Az√∫car', 'Leche'], correct: 0 },
        { q: 'üî™ ¬øQu√© significa "picar finamente"?', a: ['Cortar en trozos peque√±os', 'Cortar grueso', 'No cortar'], correct: 0 },
        { q: 'üçù ¬øCu√°nto tiempo se cocina pasta al dente?', a: ['8-10 minutos', '30 minutos', '2 minutos'], correct: 0 }
      ]
    },
    {
      id: 'driver',
      name: 'Conductor',
      emoji: 'üöó',
      unlockLevel: 1,
      questions: [
        { q: 'üö¶ Sem√°foro en √°mbar, ¬øqu√© haces?', a: ['Frenar con precauci√≥n', 'Acelerar', 'Tocar bocina'], correct: 0 },
        { q: '‚õΩ ¬øQu√© significa la luz de gasolina?', a: ['Tanque casi vac√≠o', 'Motor caliente', 'Llantas bajas'], correct: 0 },
        { q: 'üõë ¬øQu√© significa una se√±al octagonal roja?', a: ['Alto total', 'Ceda el paso', 'No estacionar'], correct: 0 },
        { q: 'üèéÔ∏è ¬øCu√°ndo usas luces altas?', a: ['Carreteras oscuras sin tr√°fico', 'Siempre', 'En la ciudad'], correct: 0 },
        { q: 'üîß ¬øCada cu√°nto cambiar aceite del motor?', a: ['5,000-10,000 km', '50,000 km', '1,000 km'], correct: 0 }
      ]
    },
    {
      id: 'teacher',
      name: 'Profesor',
      emoji: 'üë®‚Äçüè´',
      unlockLevel: 1,
      questions: [
        { q: 'üåç ¬øCu√°l es la capital de Francia?', a: ['Par√≠s', 'Londres', 'Madrid'], correct: 0 },
        { q: 'üî¢ ¬øCu√°nto es 15 x 8?', a: ['120', '100', '150'], correct: 0 },
        { q: 'üìñ ¬øQui√©n escribi√≥ Don Quijote?', a: ['Miguel de Cervantes', 'Shakespeare', 'Dante'], correct: 0 },
        { q: 'üåä ¬øCu√°l es el oc√©ano m√°s grande?', a: ['Pac√≠fico', 'Atl√°ntico', '√çndico'], correct: 0 },
        { q: 'üî¨ ¬øQu√© es H2O?', a: ['Agua', 'Ox√≠geno', 'Hidr√≥geno'], correct: 0 }
      ]
    },
    {
      id: 'doctor',
      name: 'M√©dico',
      emoji: 'üë®‚Äç‚öïÔ∏è',
      unlockLevel: 1,
      questions: [
        { q: 'ü©∫ Paciente: fiebre, tos, dolor de cabeza', a: ['Gripe', 'Alergia', 'Insolaci√≥n'], correct: 0 },
        { q: 'üíä ¬øPara qu√© sirve el paracetamol?', a: ['Bajar fiebre y dolor', 'Dormir', 'Vitamina'], correct: 0 },
        { q: '‚ù§Ô∏è ¬øCu√°ntas veces late el coraz√≥n por minuto?', a: ['60-100', '20-30', '200-300'], correct: 0 },
        { q: 'üè• ¬øQu√© es un estetoscopio?', a: ['Escuchar coraz√≥n/pulmones', 'Medir presi√≥n', 'Ver garganta'], correct: 0 },
        { q: 'ü©π ¬øQu√© haces con una herida que sangra?', a: ['Presionar con gasa', 'Ignorarla', 'Echar alcohol'], correct: 0 }
      ]
    },
    {
      id: 'streamer',
      name: 'Streamer',
      emoji: 'üéÆ',
      unlockLevel: 1,
      questions: [
        { q: 'üìπ ¬øQu√© plataforma es para streaming?', a: ['Twitch', 'WhatsApp', 'Gmail'], correct: 0 },
        { q: 'üé§ ¬øQu√© necesitas para hablar en stream?', a: ['Micr√≥fono', 'Impresora', 'Scanner'], correct: 0 },
        { q: 'üí¨ ¬øC√≥mo se llaman los espectadores?', a: ['Viewers', 'Players', 'Editors'], correct: 0 },
        { q: '‚ö° ¬øQu√© internet necesitas para streamear?', a: ['R√°pido y estable', 'Lento', 'Solo WiFi'], correct: 0 },
        { q: 'üéÅ ¬øQu√© son las subs?', a: ['Suscripciones pagadas', 'Puntos gratis', 'Emojis'], correct: 0 }
      ]
    }
  ];

  const premiumJobs = [
    {
      id: 'ceo',
      name: 'CEO',
      emoji: 'üíº',
      unlockLevel: 10,
      questions: [
        { q: 'üìä ¬øQu√© es un balance general?', a: ['Estado financiero', 'Lista de empleados', 'Inventario'], correct: 0 },
        { q: 'üí∞ ¬øQu√© es ROI?', a: ['Retorno de inversi√≥n', 'Riesgo operativo', 'Registro oficial'], correct: 0 },
        { q: 'üë• ¬øQu√© hace un CEO?', a: ['Dirige la empresa', 'Limpia oficinas', 'Contesta tel√©fonos'], correct: 0 }
      ]
    },
    {
      id: 'athlete',
      name: 'Deportista Pro',
      emoji: '‚öΩ',
      unlockLevel: 12,
      questions: [
        { q: 'üèÉ ¬øCu√°ntos minutos tiene un partido de f√∫tbol?', a: ['90 minutos', '60 minutos', '120 minutos'], correct: 0 },
        { q: 'üí™ ¬øQu√© es importante antes de entrenar?', a: ['Calentar', 'Dormir', 'Comer mucho'], correct: 0 },
        { q: 'ü•á ¬øCada cu√°ntos a√±os son las Olimpiadas?', a: ['4 a√±os', '2 a√±os', '5 a√±os'], correct: 0 }
      ]
    },
    {
      id: 'actor',
      name: 'Actor',
      emoji: 'üé¨',
      unlockLevel: 15,
      questions: [
        { q: 'üé≠ ¬øQu√© es un gui√≥n?', a: ['Di√°logos y acciones', 'Vestuario', 'Escenario'], correct: 0 },
        { q: 'üé• ¬øQu√© grita el director al empezar?', a: ['¬°Acci√≥n!', '¬°Silencio!', '¬°Corten!'], correct: 0 },
        { q: 'üèÜ ¬øCu√°l es el premio m√°s famoso del cine?', a: ['Oscar', 'Grammy', 'Emmy'], correct: 0 }
      ]
    }
  ];

  return [...baseJobs, ...premiumJobs.filter(job => workLevel >= job.unlockLevel)];
}

// Calcular XP necesario para siguiente nivel
function getXPForLevel(level) {
  return level * 200; // Nivel 1 = 200 XP, Nivel 2 = 400 XP, etc.
}

// Calcular pago base seg√∫n nivel y turno
function calculatePay(baseMin, baseMax, workLevel, shift) {
  const levelBonus = 1 + (workLevel - 1) * 0.15; // +15% por nivel
  const shiftMultiplier = { '2h': 1, '4h': 2.2, '8h': 4.5 }[shift];
  
  const min = Math.floor(baseMin * levelBonus * shiftMultiplier);
  const max = Math.floor(baseMax * levelBonus * shiftMultiplier);
  
  return { min, max };
}

// Obtener o crear usuario de econom√≠a
function getUser(userId) {
  const economy = loadEconomy();
  if (!economy[userId]) {
    economy[userId] = {
      coins: 1000,
      bank: 0,
      lastDaily: 0,
      lastWork: 0,
      lastSpin: 0,
      lastActive: Date.now(),
      streak: 0,
      loan: null, // { amount, deadline, paid }
      quests: [],
      inventory: [],
      titles: [],
      workLevel: 1,
      workXP: 0,
      workStreak: 0,
      lastWorkDate: null,
      stats: {
        gamesPlayed: 0,
        gamesWon: 0,
        gamesLost: 0,
        totalWinnings: 0,
        totalLosses: 0
      }
    };
    saveEconomy(economy);
  }
  
  // Migrar usuarios existentes
  if (economy[userId].bank === undefined) economy[userId].bank = 0;
  if (economy[userId].lastWork === undefined) economy[userId].lastWork = 0;
  if (economy[userId].lastSpin === undefined) economy[userId].lastSpin = 0;
  if (economy[userId].lastActive === undefined) economy[userId].lastActive = Date.now();
  if (economy[userId].streak === undefined) economy[userId].streak = 0;
  if (economy[userId].loan === undefined) economy[userId].loan = null;
  if (economy[userId].quests === undefined) economy[userId].quests = [];
  if (economy[userId].workLevel === undefined) economy[userId].workLevel = 1;
  if (economy[userId].workXP === undefined) economy[userId].workXP = 0;
  if (economy[userId].workStreak === undefined) economy[userId].workStreak = 0;
  if (economy[userId].lastWorkDate === undefined) economy[userId].lastWorkDate = null;
  
  return economy[userId];
}

function updateUser(userId, data) {
  const economy = loadEconomy();
  economy[userId] = { ...economy[userId], ...data };
  saveEconomy(economy);
}

client.once('ready', async () => {
  console.log(`‚úÖ Bot listo: ${client.user.tag}`);
  
  // Registrar comandos ejecutando register.js
  try {
    console.log('üîÑ Registrando comandos slash...');
    require('./register.js');
  } catch (error) {
    console.error('‚ùå Error registrando comandos:', error);
  }
  
  // Crear backup inicial
  createBackup();
  
  // Backup autom√°tico cada hora (3600000 ms)
  setInterval(() => {
    createBackup();
  }, 3600000);

  // Verificar tickets inactivos cada 30 minutos
  setInterval(async () => {
    try {
      const tickets = loadTickets();
      const now = Date.now();
      const inactivityLimit = 48 * 60 * 60 * 1000; // 48 horas en ms

      for (const [channelId, ticket] of Object.entries(tickets)) {
        if (ticket.status !== 'open') continue;
        if (!ticket.lastUserActivity) continue;

        const timeSinceLastActivity = now - ticket.lastUserActivity;

        if (timeSinceLastActivity >= inactivityLimit) {
          try {
            const channel = await client.channels.fetch(channelId);
            if (!channel) {
              delete tickets[channelId];
              continue;
            }

            // Avisar que se va a cerrar
            const warningEmbed = new EmbedBuilder()
              .setColor('#e67e22')
              .setTitle('‚ö†Ô∏è Ticket Inactivo')
              .setDescription('Este ticket ser√° cerrado por inactividad del usuario.')
              .addFields(
                { name: '‚è∞ √öltima actividad', value: `<t:${Math.floor(ticket.lastUserActivity / 1000)}:R>`, inline: true },
                { name: 'üîí Cerrando en', value: '30 segundos', inline: true }
              )
              .setFooter({ text: 'El usuario no ha respondido en 48 horas' })
              .setTimestamp();

            await channel.send({ embeds: [warningEmbed] });

            // Esperar 30 segundos antes de cerrar
            setTimeout(async () => {
              try {
                const closedEmbed = new EmbedBuilder()
                  .setColor('#e74c3c')
                  .setTitle('üîí Ticket Cerrado Autom√°ticamente')
                  .setDescription('Este ticket ha sido cerrado por inactividad del usuario (48 horas sin respuesta).')
                  .setFooter({ text: '¬© Ea$y Esports | Sistema Autom√°tico' })
                  .setTimestamp();

                await channel.send({ embeds: [closedEmbed] });

                // Log de cierre autom√°tico
                try {
                  const canalLogs = await client.channels.fetch(CANAL_LOGS);
                  const usuario = await client.users.fetch(ticket.userId);
                  const tipoTicket = ticket.tipo === 'reclutamiento' ? 'Reclutamiento' : 
                                    ticket.tipo === 'crear_soporte_reporte' ? 'Reporte' :
                                    ticket.tipo === 'crear_soporte_duda' ? 'Duda' : 'Soporte';

                  const logEmbed = new EmbedBuilder()
                    .setColor('#e67e22')
                    .setTitle('üîí Ticket Cerrado Autom√°ticamente')
                    .setDescription('‚ö†Ô∏è Ticket cerrado por inactividad del usuario')
                    .addFields(
                      { name: 'üë§ Usuario:', value: `${usuario} (${usuario.tag})`, inline: true },
                      { name: 'üìã Tipo:', value: tipoTicket, inline: true },
                      { name: '‚è∞ Inactivo por:', value: '48 horas', inline: true },
                      { name: 'üìÖ Creado:', value: `<t:${Math.floor(new Date(ticket.createdAt).getTime() / 1000)}:F>`, inline: true },
                      { name: 'üïê √öltima actividad:', value: `<t:${Math.floor(ticket.lastUserActivity / 1000)}:R>`, inline: true }
                    )
                    .setThumbnail(usuario.displayAvatarURL())
                    .setFooter({ text: '¬© Ea$y Esports | Sistema de Auto-cierre' })
                    .setTimestamp();

                  await canalLogs.send({ embeds: [logEmbed] });
                } catch (error) {
                  console.error('Error al enviar log de auto-cierre:', error);
                }

                // Eliminar ticket del registro y canal
                delete tickets[channelId];
                saveTickets(tickets);

                setTimeout(async () => {
                  await channel.delete().catch(console.error);
                }, 5000);

              } catch (error) {
                console.error('Error al cerrar ticket autom√°ticamente:', error);
              }
            }, 30000);

          } catch (error) {
            console.error('Error al procesar ticket inactivo:', error);
          }
        }
      }
      
      saveTickets(tickets);
    } catch (error) {
      console.error('Error en verificaci√≥n de tickets inactivos:', error);
    }
  }, 1800000); // Cada 30 minutos
});

// Manejar mensajes para el juego de adivinar el n√∫mero
client.on('messageCreate', async (message) => {
  if (message.author.bot) return;

  // Actualizar actividad del usuario en tickets
  const tickets = loadTickets();
  const ticket = tickets[message.channel.id];
  if (ticket && ticket.userId === message.author.id && ticket.status === 'open') {
    ticket.lastUserActivity = Date.now();
    saveTickets(tickets);
  }

  // Buscar si el usuario tiene un juego activo
  for (const [gameId, game] of activeGames.entries()) {
    if (gameId.startsWith('guess_') && game.userId === message.author.id) {
      const guess = parseInt(message.content);
      
      if (isNaN(guess) || guess < 1 || guess > 100) {
        continue; // Ignorar mensajes que no sean n√∫meros v√°lidos
      }

      game.attempts++;

      if (guess === game.targetNumber) {
        const multipliers = [0, 5, 4, 3, 2, 1];
        const multiplier = multipliers[game.attempts];
        const winnings = game.bet * multiplier;

        const userData = getUser(message.author.id);
        userData.coins += winnings - game.bet;
        userData.stats.gamesPlayed++;
        userData.stats.gamesWon++;
        userData.stats.totalWinnings += winnings - game.bet;
        updateUser(message.author.id, userData);

        const medals = ['', 'ü•á', 'ü•à', 'ü•â', 'üéñÔ∏è', '‚≠ê'];
        const resultBox = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë                                              ‚ïë\n‚ïë  ${medals[game.attempts]} **¬°CORRECTO!** ${medals[game.attempts]}  ‚ïë\n‚ïë   El n√∫mero era **${game.targetNumber}**   ‚ïë\n‚ïë                                              ‚ïë\n‚ïë  üí∞ **+${(winnings - game.bet).toLocaleString()} ü™ô** (${multiplier}x)  ‚ïë\n‚ïë                                              ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`;

        const embed = new EmbedBuilder()
          .setColor('#2ecc71')
          .setTitle('üî¢ Adivina el N√∫mero - ¬°ACERTASTE!')
          .setDescription(resultBox)
          .addFields(
            { name: 'üéØ Intentos', value: `**${game.attempts}**/${game.maxAttempts}`, inline: true },
            { name: 'üíé Multiplicador', value: `**${multiplier}x**`, inline: true },
            { name: 'üèÜ Premio', value: `**${(winnings - game.bet).toLocaleString()}** ü™ô`, inline: true }
          )
          .setFooter({ text: `üí∞ Nuevo balance: ${userData.coins.toLocaleString()} ü™ô` });

        await message.reply({ embeds: [embed] });
        activeGames.delete(gameId);
        break;
      } else {
        if (game.attempts >= game.maxAttempts) {
          const userData = getUser(message.author.id);
          userData.coins -= game.bet;
          userData.stats.gamesPlayed++;
          userData.stats.gamesLost++;
          userData.stats.totalLosses += game.bet;
          updateUser(message.author.id, userData);

          const embed = new EmbedBuilder()
            .setColor('#e74c3c')
            .setTitle('üî¢ Adivina el N√∫mero - Game Over')
            .setDescription(`‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë                                      ‚ïë\n‚ïë  üíÄ **GAME OVER** üíÄ  ‚ïë\n‚ïë                                      ‚ïë\n‚ïë  El n√∫mero era **${game.targetNumber}**  ‚ïë\n‚ïë  **-${game.bet.toLocaleString()} ü™ô**  ‚ïë\n‚ïë                                      ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`)
            .setFooter({ text: `üí∞ Nuevo balance: ${userData.coins.toLocaleString()} ü™ô | ¬°Mejor suerte la pr√≥xima vez!` });

          await message.reply({ embeds: [embed] });
          activeGames.delete(gameId);
          break;
        } else {
          const hint = guess < game.targetNumber ? '‚¨ÜÔ∏è **M√ÅS ALTO**' : '‚¨áÔ∏è **M√ÅS BAJO**';
          const attemptsLeft = game.maxAttempts - game.attempts;
          
          // Determinar qu√© tan cerca est√°
          const difference = Math.abs(guess - game.targetNumber);
          let temperature = '';
          let tempColor = '#e74c3c';
          
          if (difference <= 5) {
            temperature = 'üî• **¬°CALIENTE!** üî•';
            tempColor = '#e74c3c';
          } else if (difference <= 15) {
            temperature = 'üå°Ô∏è **Tibio**';
            tempColor = '#f39c12';
          } else {
            temperature = '‚ùÑÔ∏è **Fr√≠o**';
            tempColor = '#3498db';
          }

          const embed = new EmbedBuilder()
            .setColor(tempColor)
            .setTitle('üî¢ Adivina el N√∫mero')
            .setDescription(`‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë                                      ‚ïë\n‚ïë   ‚ùå **${guess}** ‚ùå   ‚ïë\n‚ïë                                      ‚ïë\n‚ïë   ${hint}   ‚ïë\n‚ïë   ${temperature}   ‚ïë\n‚ïë                                      ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`)
            .addFields(
              { name: 'üéØ Intentos restantes', value: `**${attemptsLeft}**`, inline: true },
              { name: 'üí° Pista', value: hint, inline: true }
            )
            .setFooter({ text: 'üí≠ Sigue intentando... ¬°Est√°s cerca!' });

          await message.reply({ embeds: [embed] });
        }
      }
      break;
    }
  }
});

client.on('interactionCreate', async interaction => {
  // Bot√≥n: Crear ticket reclutamiento
  if (interaction.isButton() && interaction.customId === 'crear_reclutamiento') {
    const tickets = loadTickets();
    const userTickets = Object.values(tickets).filter(t => t.userId === interaction.user.id && t.status === 'open');
    
    if (userTickets.length > 0) {
      return interaction.reply({ content: '‚ùå Ya tienes un ticket abierto.', flags: 64 });
    }

    const modal = new ModalBuilder()
      .setCustomId('modal_reclutamiento')
      .setTitle('Postulaci√≥n Easy Esports');

    modal.addComponents(
      new ActionRowBuilder().addComponents(
        new TextInputBuilder()
          .setCustomId('nombre')
          .setLabel('Nombre y Edad')
          .setStyle(TextInputStyle.Short)
          .setRequired(true)
      ),
      new ActionRowBuilder().addComponents(
        new TextInputBuilder()
          .setCustomId('activision')
          .setLabel('Activision ID')
          .setStyle(TextInputStyle.Short)
          .setRequired(true)
      ),
      new ActionRowBuilder().addComponents(
        new TextInputBuilder()
          .setCustomId('stats')
          .setLabel('Rol y KD')
          .setStyle(TextInputStyle.Short)
          .setRequired(true)
      ),
      new ActionRowBuilder().addComponents(
        new TextInputBuilder()
          .setCustomId('disponibilidad')
          .setLabel('Disponibilidad y Torneos')
          .setStyle(TextInputStyle.Paragraph)
          .setRequired(true)
      ),
      new ActionRowBuilder().addComponents(
        new TextInputBuilder()
          .setCustomId('presentacion')
          .setLabel('Presentaci√≥n')
          .setStyle(TextInputStyle.Paragraph)
          .setRequired(true)
      )
    );

    await interaction.showModal(modal);
  }

  // Modal: Procesar reclutamiento
  if (interaction.isModalSubmit() && interaction.customId === 'modal_reclutamiento') {
    await interaction.deferReply({ flags: 64 }); // 64 = Ephemeral

    const nombre = interaction.fields.getTextInputValue('nombre');
    const activision = interaction.fields.getTextInputValue('activision');
    const stats = interaction.fields.getTextInputValue('stats');
    const disponibilidad = interaction.fields.getTextInputValue('disponibilidad');
    const presentacion = interaction.fields.getTextInputValue('presentacion');

    // Crear permisos para m√∫ltiples roles de staff
    const staffRoleIds = getStaffRoles();
    const permissionOverwrites = [
      { id: interaction.guild.id, deny: [PermissionFlagsBits.ViewChannel] },
      { id: interaction.user.id, allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.SendMessages, PermissionFlagsBits.AttachFiles, PermissionFlagsBits.EmbedLinks, PermissionFlagsBits.ReadMessageHistory] },
      ...staffRoleIds.map(roleId => ({
        id: roleId,
        allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.SendMessages, PermissionFlagsBits.AttachFiles, PermissionFlagsBits.EmbedLinks, PermissionFlagsBits.ReadMessageHistory]
      }))
    ];

    // Crear canal
    const canal = await interaction.guild.channels.create({
      name: `reclutamiento-${interaction.user.username}`,
      type: 0,
      parent: process.env.CATEGORIA_RECLUTAMIENTO,
      permissionOverwrites
    });

    // Guardar ticket
    const tickets = loadTickets();
    tickets[canal.id] = {
      id: canal.id,
      userId: interaction.user.id,
      username: interaction.user.username,
      tipo: 'reclutamiento',
      data: { nombre, activision, stats, disponibilidad, presentacion },
      createdAt: new Date().toISOString(),
      lastUserActivity: Date.now(),
      status: 'open'
    };
    saveTickets(tickets);
    console.log(`‚úÖ Ticket guardado: ${canal.id} | Usuario: ${interaction.user.username}`);

    // Embed con datos del usuario
    const embedDatos = new EmbedBuilder()
      .setColor('#00FF00')
      .setTitle('üìã Nueva Postulaci√≥n - Ea$y Esports')
      .setDescription(`**${interaction.user}** ha enviado una solicitud para unirse al equipo.\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`)
      .addFields(
        { name: 'üë§ Nombre y Edad', value: `\`\`\`${nombre}\`\`\``, inline: false },
        { name: 'üéÆ Activision ID', value: `\`\`\`${activision}\`\`\``, inline: false },
        { name: 'üìä Rol y KD', value: `\`\`\`${stats}\`\`\``, inline: false },
        { name: 'üïê Disponibilidad y Torneos', value: `\`\`\`${disponibilidad}\`\`\``, inline: false },
        { name: 'üìù Presentaci√≥n', value: `\`\`\`${presentacion}\`\`\``, inline: false }
      )
      .setFooter({ text: '¬© Ea$y Esports | Sistema de Reclutamiento' })
      .setTimestamp();

    // Embed pidiendo pruebas
    const embedPruebas = new EmbedBuilder()
      .setColor('#FF6B00')
      .setTitle('üì∏ Pruebas Obligatorias')
      .setDescription(`**${interaction.user.username}**, para continuar con tu postulaci√≥n debes enviar las siguientes pruebas:\n`)
      .addFields(
        { 
          name: 'üéØ Requisitos:', 
          value: '‚Ä¢ Screenshots de tus **estad√≠sticas** (WZRank, K/D, Wins)\n‚Ä¢ Clips o **VODs** de tus mejores jugadas\n‚Ä¢ Capturas de **torneos ganados** o participaciones\n‚Ä¢ **Pruebas de gameplay** que demuestren tu nivel',
          inline: false 
        },
        { 
          name: '‚ö†Ô∏è Importante:', 
          value: '> Las pruebas deben ser **claras y verificables**\n> Puedes subir im√°genes directamente o compartir enlaces\n> El Staff revisar√° tu postulaci√≥n una vez env√≠es las pruebas',
          inline: false 
        },
        { 
          name: '‚úÖ Siguiente paso:', 
          value: '*Sube tus pruebas en este canal y espera la respuesta del Staff*',
          inline: false 
        }
      )
      .setThumbnail('https://cdn.discordapp.com/attachments/1309783318031503384/1431136085756608644/Fondo_1_3.png')
      .setFooter({ text: 'Recuerda ser honesto y transparente' });

    const botones = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('reclamar_ticket')
        .setLabel('‚úã Reclamar')
        .setStyle(ButtonStyle.Success),
      new ButtonBuilder()
        .setCustomId('cerrar_ticket')
        .setLabel('üîí Cerrar')
        .setStyle(ButtonStyle.Danger)
    );

    // Mencionar rol espec√≠fico de reclutamiento
    await canal.send({ content: `<@&1382022718899355688>`, embeds: [embedDatos] });
    await canal.send({ embeds: [embedPruebas], components: [botones] });

    // Log de apertura
    try {
      const canalLogs = await interaction.guild.channels.fetch(CANAL_LOGS);
      const embedLog = new EmbedBuilder()
        .setColor('#2ecc71')
        .setTitle('üìã Nuevo Ticket Abierto')
        .addFields(
          { name: 'üë§ Usuario:', value: `${interaction.user} (${interaction.user.tag})`, inline: true },
          { name: 'üìã Tipo:', value: 'Reclutamiento', inline: true },
          { name: 'üîó Canal:', value: `${canal}`, inline: true },
          { name: 'üìÖ Fecha:', value: `<t:${Math.floor(Date.now() / 1000)}:F>`, inline: false }
        )
        .setThumbnail(interaction.user.displayAvatarURL())
        .setFooter({ text: '¬© Ea$y Esports | Sistema de Logs' })
        .setTimestamp();
      
      await canalLogs.send({ embeds: [embedLog] });
    } catch (error) {
      console.error('Error al enviar log:', error);
    }

    await interaction.editReply({ content: `‚úÖ Ticket creado: ${canal}` });
  }

  // Bot√≥n: Reclamar ticket
  if (interaction.isButton() && interaction.customId === 'reclamar_ticket') {
    const tickets = loadTickets();
    console.log(`üîç Intentando reclamar ticket en canal: ${interaction.channel.id}`);
    console.log(`üìã Tickets cargados:`, Object.keys(tickets));
    const ticket = tickets[interaction.channel.id];

    if (!ticket) {
      console.log(`‚ùå Ticket no encontrado para canal: ${interaction.channel.id}`);
      return interaction.reply({ content: '‚ùå No es un ticket v√°lido.', flags: 64 });
    }

    if (ticket.reclamadoPor) {
      return interaction.reply({ content: `‚ùå Este ticket ya fue reclamado por <@${ticket.reclamadoPor}>.`, flags: 64 });
    }

    ticket.reclamadoPor = interaction.user.id;
    saveTickets(tickets);

    const embed = new EmbedBuilder()
      .setColor('#2ecc71')
      .setDescription(`‚úÖ **${interaction.user}** ha reclamado este ticket y se encargar√° de atenderlo.`)
      .setTimestamp();

    await interaction.reply({ embeds: [embed] });
  }

  // Bot√≥n: Cerrar ticket
  if (interaction.isButton() && interaction.customId === 'cerrar_ticket') {
    const tickets = loadTickets();
    const ticket = tickets[interaction.channel.id];

    if (!ticket) {
      return interaction.reply({ content: '‚ùå No es un ticket v√°lido.', flags: 64 });
    }

    await interaction.reply({ content: '‚úÖ Cerrando ticket...', flags: 64 });

    const tipoTicket = ticket.tipo === 'reclutamiento' ? 'Reclutamiento' : 
                       ticket.tipo === 'soporte_tecnico' ? 'Soporte T√©cnico' :
                       ticket.tipo === 'soporte_reporte' ? 'Reporte de Jugador' :
                       ticket.tipo === 'soporte_apelacion' ? 'Apelaci√≥n' : 'Consulta General';

    const embed = new EmbedBuilder()
      .setColor('#e74c3c')
      .setTitle('üîí Ticket Cerrado')
      .setDescription(`Este ticket ha sido cerrado y ser√° eliminado en breve.\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`)
      .addFields(
        { name: 'üë§ Cerrado por:', value: `${interaction.user}`, inline: true },
        { name: 'üìã Tipo:', value: tipoTicket, inline: true },
        { name: '‚è∞ Duraci√≥n:', value: `<t:${Math.floor(new Date(ticket.createdAt).getTime() / 1000)}:R>`, inline: true }
      )
      .setFooter({ text: '¬© Ea$y Esports | Gracias por tu tiempo' })
      .setTimestamp();

    await interaction.channel.send({ embeds: [embed] });

    // Log de cierre
    try {
      const canalLogs = await interaction.guild.channels.fetch(CANAL_LOGS);
      const usuario = await interaction.guild.members.fetch(ticket.userId);
      
      const embedLog = new EmbedBuilder()
        .setColor('#e74c3c')
        .setTitle('üîí Ticket Cerrado')
        .addFields(
          { name: 'üë§ Usuario:', value: `${usuario.user} (${usuario.user.tag})`, inline: true },
          { name: 'üìã Tipo:', value: tipoTicket, inline: true },
          { name: 'üîí Cerrado por:', value: `${interaction.user}`, inline: true },
          { name: 'üìÖ Creado:', value: `<t:${Math.floor(new Date(ticket.createdAt).getTime() / 1000)}:F>`, inline: true },
          { name: '‚è∞ Duraci√≥n:', value: `<t:${Math.floor(new Date(ticket.createdAt).getTime() / 1000)}:R>`, inline: true },
          { name: 'üë®‚Äçüíº Reclamado por:', value: ticket.reclamadoPor ? `<@${ticket.reclamadoPor}>` : 'Nadie', inline: true }
        )
        .setThumbnail(usuario.user.displayAvatarURL())
        .setFooter({ text: '¬© Ea$y Esports | Sistema de Logs' })
        .setTimestamp();
      
      await canalLogs.send({ embeds: [embedLog] });
    } catch (error) {
      console.error('Error al enviar log de cierre:', error);
    }

    tickets[interaction.channel.id].status = 'closed';
    saveTickets(tickets);

    setTimeout(async () => {
      delete tickets[interaction.channel.id];
      saveTickets(tickets);
      await interaction.channel.delete().catch(() => {});
    }, 5000);
  }

  // Comando: Panel reclutamiento (Solo Admin)
  if (interaction.isChatInputCommand() && interaction.commandName === 'panel-reclutamiento') {
    if (!interaction.member.permissions.has(PermissionFlagsBits.Administrator)) {
      return interaction.reply({ content: '‚ùå Necesitas permisos de administrador para usar este comando.', flags: 64 });
    }

    const embed = new EmbedBuilder()
      .setColor('#00FF00')
      .setTitle('‚öîÔ∏è Reclutamiento Ea$y')
      .setDescription('¬øQuieres unirte a **Ea$y Esports**? Completa tu solicitud y el Staff la revisar√°.\n\nRecuerda que buscamos jugadores **activos, competitivos y con disciplina**.\nüìå **Formato obligatorio de postulaci√≥n:**\n\n‚Ä¢ üéÆ **Activision ID**\n\n‚Ä¢ üéØ **Rol de juego** (üîµ Ancla / üî¥ IGL / üü° Support / üü¢ Fragger)\n\n‚Ä¢ üî´ **KD** / WZRank, Resurgimiento, BattleRoyale.\n\n‚Ä¢ ‚è∞ **Disponibilidad** (d√≠as/horas)\n\n‚Ä¢ üèÜ **Torneos ganados:** (indica cu√°ntos has participado y ganado, pruebas)\n\n‚Ä¢ üé¨ **Pruebas:** clips, VODs o capturas de tus jugadas\n\n‚Ä¢ üë§ **Breve presentaci√≥n personal**')
      .setImage('https://cdn.discordapp.com/attachments/1309783318031503384/1431136085756608644/Fondo_1_3.png')
      .setFooter({ text: '¬© Ea$y Esports | Sistema de Reclutamiento' });

    const boton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('crear_reclutamiento')
        .setLabel('üìù Postularme')
        .setStyle(ButtonStyle.Success)
    );

    await interaction.channel.send({ embeds: [embed], components: [boton] });
    await interaction.reply({ content: '‚úÖ Panel creado.', flags: 64 });
  }

  // Comando: Panel soporte (Solo Admin)
  if (interaction.isChatInputCommand() && interaction.commandName === 'panel-soporte') {
    if (!interaction.member.permissions.has(PermissionFlagsBits.Administrator)) {
      return interaction.reply({ content: '‚ùå Necesitas permisos de administrador para usar este comando.', flags: 64 });
    }

    const embed = new EmbedBuilder()
      .setColor('#00FF00')
      .setTitle('‚öîÔ∏è Reclutamiento Ea$y')
      .setDescription('¬øQuieres unirte a **Ea$y Esports**? Completa tu solicitud y el Staff la revisar√°.\n\nRecuerda que buscamos jugadores **activos, competitivos y con disciplina**.\nüìå **Formato obligatorio de postulaci√≥n:**\n\n‚Ä¢ üéÆ **Activision ID**\n\n‚Ä¢ üéØ **Rol de juego** (üîµ Ancla / üî¥ IGL / üü° Support / üü¢ Fragger)\n\n‚Ä¢ üî´ **KD** / WZRank, Resurgimiento, BattleRoyale.\n\n‚Ä¢ ‚è∞ **Disponibilidad** (d√≠as/horas)\n\n‚Ä¢ üèÜ **Torneos ganados:** (indica cu√°ntos has participado y ganado, pruebas)\n\n‚Ä¢ üé¨ **Pruebas:** clips, VODs o capturas de tus jugadas\n\n‚Ä¢ üë§ **Breve presentaci√≥n personal**')
      .setImage('https://cdn.discordapp.com/attachments/1309783318031503384/1431136085756608644/Fondo_1_3.png')
      .setFooter({ text: '¬© Ea$y Esports | Sistema de Reclutamiento' });

    const boton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('crear_reclutamiento')
        .setLabel('üìù Postularme')
        .setStyle(ButtonStyle.Success)
    );

    await interaction.channel.send({ embeds: [embed], components: [boton] });
    await interaction.reply({ content: '‚úÖ Panel creado.', flags: 64 });
  }

  // Comando: Panel soporte
  if (interaction.isChatInputCommand() && interaction.commandName === 'panel-soporte') {
    const embed = new EmbedBuilder()
      .setColor('#3498db')
      .setTitle('üõ†Ô∏è Ticket-Soporte')
      .setDescription('¬øNecesitas ayuda del Staff? Abre un ticket y te atenderemos lo antes posible.\n\nPor favor, elige la categor√≠a correcta para agilizar tu caso.\n\n‚Ä¢ üß∞ **Soporte t√©cnico** ‚Äì problemas con Discord o bots\n\n‚Ä¢ üö´ **Reporte de jugador** ‚Äì conductas t√≥xicas / chetos\n\n‚Ä¢ üìú **Apelaciones** ‚Äì sanciones o advertencias\n\n‚Ä¢ ‚ùì **Otras consultas** ‚Äì cualquier tema general\n\nüëâ Presiona el bot√≥n de abajo para crear tu ticket. S√© claro y adjunta capturas si es necesario.')
      .setImage('https://cdn.discordapp.com/attachments/1309783318031503384/1431136085756608644/Fondo_1_3.png')
      .setFooter({ text: '¬© Soporte Ea$y Esports' });

    const row1 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('soporte_tecnico')
        .setLabel('üß∞ Soporte T√©cnico')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('soporte_reporte')
        .setLabel('üö´ Reporte de Jugador')
        .setStyle(ButtonStyle.Danger)
    );

    const row2 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('soporte_apelacion')
        .setLabel('üìú Apelaciones')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('soporte_consulta')
        .setLabel('‚ùì Otras Consultas')
        .setStyle(ButtonStyle.Success)
    );

    await interaction.channel.send({ embeds: [embed], components: [row1, row2] });
    await interaction.reply({ content: '‚úÖ Panel de soporte creado.', flags: 64 });
  }

  // Botones de soporte
  if (interaction.isButton() && interaction.customId.startsWith('soporte_')) {
    const tickets = loadTickets();
    const userTickets = Object.values(tickets).filter(t => t.userId === interaction.user.id && t.status === 'open');
    
    if (userTickets.length > 0) {
      return interaction.reply({ content: '‚ùå Ya tienes un ticket abierto.', flags: 64 });
    }

    await interaction.deferReply({ flags: 64 });

    const tipos = {
      'soporte_tecnico': { nombre: 'Soporte T√©cnico', emoji: 'üß∞' },
      'soporte_reporte': { nombre: 'Reporte de Jugador', emoji: 'üö´' },
      'soporte_apelacion': { nombre: 'Apelaci√≥n', emoji: 'üìú' },
      'soporte_consulta': { nombre: 'Consulta General', emoji: '‚ùì' }
    };

    const tipo = tipos[interaction.customId];

    // Crear permisos para m√∫ltiples roles de staff
    const staffRoleIds = getStaffRoles();
    const permissionOverwrites = [
      { id: interaction.guild.id, deny: [PermissionFlagsBits.ViewChannel] },
      { id: interaction.user.id, allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.SendMessages, PermissionFlagsBits.AttachFiles, PermissionFlagsBits.EmbedLinks, PermissionFlagsBits.ReadMessageHistory] },
      ...staffRoleIds.map(roleId => ({
        id: roleId,
        allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.SendMessages, PermissionFlagsBits.AttachFiles, PermissionFlagsBits.EmbedLinks, PermissionFlagsBits.ReadMessageHistory]
      }))
    ];

    // Crear canal
    const canal = await interaction.guild.channels.create({
      name: `${tipo.emoji}-${interaction.user.username}`,
      type: 0,
      parent: '1431157269453869086',
      permissionOverwrites
    });

    // Guardar ticket
    tickets[canal.id] = {
      id: canal.id,
      userId: interaction.user.id,
      username: interaction.user.username,
      tipo: interaction.customId,
      createdAt: new Date().toISOString(),
      lastUserActivity: Date.now(),
      status: 'open'
    };
    saveTickets(tickets);
    console.log(`‚úÖ Ticket de soporte guardado: ${canal.id} | Usuario: ${interaction.user.username} | Tipo: ${interaction.customId}`);

    // Embed del ticket
    const embedTicket = new EmbedBuilder()
      .setColor('#3498db')
      .setTitle(`${tipo.emoji} ${tipo.nombre}`)
      .setDescription(`**${interaction.user}** ha creado un ticket de **${tipo.nombre}**.\n\nPor favor, describe tu problema o consulta de forma clara y detallada.\n\n**El Staff te atender√° pronto.**`)
      .setFooter({ text: '¬© Soporte Ea$y Esports' })
      .setTimestamp();

    const botonesTicket = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('reclamar_ticket')
        .setLabel('‚úã Reclamar')
        .setStyle(ButtonStyle.Success),
      new ButtonBuilder()
        .setCustomId('cerrar_ticket')
        .setLabel('üîí Cerrar')
        .setStyle(ButtonStyle.Danger)
    );

    // Mencionar todos los roles de staff
    // Mencionar rol espec√≠fico de soporte
    await canal.send({ content: `<@&1241211764100698203>`, embeds: [embedTicket], components: [botonesTicket] });

    // Log de apertura
    try {
      const canalLogs = await interaction.guild.channels.fetch(CANAL_LOGS);
      const embedLog = new EmbedBuilder()
        .setColor('#3498db')
        .setTitle('üìã Nuevo Ticket Abierto')
        .addFields(
          { name: 'üë§ Usuario:', value: `${interaction.user} (${interaction.user.tag})`, inline: true },
          { name: 'üìã Tipo:', value: tipo.nombre, inline: true },
          { name: 'üîó Canal:', value: `${canal}`, inline: true },
          { name: 'üìÖ Fecha:', value: `<t:${Math.floor(Date.now() / 1000)}:F>`, inline: false }
        )
        .setThumbnail(interaction.user.displayAvatarURL())
        .setFooter({ text: '¬© Ea$y Esports | Sistema de Logs' })
        .setTimestamp();
      
      await canalLogs.send({ embeds: [embedLog] });
    } catch (error) {
      console.error('Error al enviar log:', error);
    }

    await interaction.editReply({ content: `‚úÖ Ticket creado: ${canal}` });
  }

  // ========== COMANDOS DE ECONOM√çA ==========

  // Comando: Balance
  if (interaction.isChatInputCommand() && interaction.commandName === 'balance') {
    const targetUser = interaction.options.getUser('usuario') || interaction.user;
    const userData = getUser(targetUser.id);

    const embed = new EmbedBuilder()
      .setColor('#f1c40f')
      .setTitle(`üí∞ Balance de ${targetUser.username}`)
      .setDescription(`**${userData.coins.toLocaleString()}** ü™ô Ea$y Coins`)
      .addFields(
        { name: 'üéÆ Partidas jugadas', value: `${userData.stats.gamesPlayed}`, inline: true },
        { name: '‚úÖ Victorias', value: `${userData.stats.gamesWon}`, inline: true },
        { name: '‚ùå Derrotas', value: `${userData.stats.gamesLost}`, inline: true }
      )
      .setThumbnail(targetUser.displayAvatarURL())
      .setFooter({ text: '¬© Ea$y Esports | Sistema de Econom√≠a' })
      .setTimestamp();

    await interaction.reply({ embeds: [embed] });
  }

  // Comando: Daily
  if (interaction.isChatInputCommand() && interaction.commandName === 'daily') {
    const userData = getUser(interaction.user.id);
    const now = Date.now();
    const cooldown = 24 * 60 * 60 * 1000; // 24 horas

    if (userData.lastDaily && (now - userData.lastDaily) < cooldown) {
      const timeLeft = cooldown - (now - userData.lastDaily);
      const hours = Math.floor(timeLeft / (60 * 60 * 1000));
      const minutes = Math.floor((timeLeft % (60 * 60 * 1000)) / (60 * 1000));

      return interaction.reply({ 
        content: `‚è∞ Ya reclamaste tu bonus diario. Vuelve en **${hours}h ${minutes}m**`,
        flags: 64 
      });
    }

    userData.coins += 100;
    userData.lastDaily = now;
    updateUser(interaction.user.id, userData);

    const embed = new EmbedBuilder()
      .setColor('#2ecc71')
      .setTitle('üéÅ Bonus Diario Reclamado')
      .setDescription(`Has recibido **100** ü™ô\n\nNuevo balance: **${userData.coins.toLocaleString()}** ü™ô`)
      .setFooter({ text: 'Vuelve ma√±ana por m√°s!' })
      .setTimestamp();

    await interaction.reply({ embeds: [embed] });
  }

  // Comando: Leaderboard
  if (interaction.isChatInputCommand() && interaction.commandName === 'leaderboard') {
    const economy = loadEconomy();
    const sorted = Object.entries(economy)
      .sort(([, a], [, b]) => b.coins - a.coins)
      .slice(0, 10);

    let description = '';
    for (let i = 0; i < sorted.length; i++) {
      const [userId, data] = sorted[i];
      const user = await interaction.guild.members.fetch(userId).catch(() => null);
      const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : `${i + 1}.`;
      description += `${medal} **${user ? user.user.username : 'Usuario Desconocido'}** - ${data.coins.toLocaleString()} ü™ô\n`;
    }

    const embed = new EmbedBuilder()
      .setColor('#f39c12')
      .setTitle('üèÜ Top 10 - M√°s Ricos')
      .setDescription(description || 'No hay datos a√∫n')
      .setFooter({ text: '¬© Ea$y Esports | Leaderboard' })
      .setTimestamp();

    await interaction.reply({ embeds: [embed] });
  }

  // Comando: Give
  if (interaction.isChatInputCommand() && interaction.commandName === 'give') {
    const targetUser = interaction.options.getUser('usuario');
    const amount = interaction.options.getInteger('cantidad');

    if (targetUser.id === interaction.user.id) {
      return interaction.reply({ content: '‚ùå No puedes regalarte monedas a ti mismo.', flags: 64 });
    }

    if (targetUser.bot) {
      return interaction.reply({ content: '‚ùå No puedes regalar monedas a un bot.', flags: 64 });
    }

    if (amount <= 0) {
      return interaction.reply({ content: '‚ùå La cantidad debe ser mayor a 0.', flags: 64 });
    }

    const senderData = getUser(interaction.user.id);
    
    // Comisi√≥n del 5% en transferencias
    const commission = Math.floor(amount * 0.05);
    const totalCost = amount + commission;

    if (senderData.coins < totalCost) {
      return interaction.reply({ 
        content: `‚ùå No tienes suficientes monedas.\nüí∞ Necesitas: **${totalCost.toLocaleString()}** ü™ô (${amount.toLocaleString()} + ${commission.toLocaleString()} comisi√≥n)\nüí∞ Tienes: **${senderData.coins.toLocaleString()}** ü™ô`, 
        flags: 64 
      });
    }

    senderData.coins -= totalCost;
    updateUser(interaction.user.id, senderData);

    const receiverData = getUser(targetUser.id);
    receiverData.coins += amount;
    updateUser(targetUser.id, receiverData);

    const embed = new EmbedBuilder()
      .setColor('#3498db')
      .setTitle('üí∏ Transferencia Exitosa')
      .setDescription(`**${interaction.user.username}** ha enviado **${amount.toLocaleString()}** ü™ô a **${targetUser.username}**`)
      .addFields(
        { name: 'üí∞ Monto enviado', value: `${amount.toLocaleString()} ü™ô`, inline: true },
        { name: 'üìä Comisi√≥n (5%)', value: `${commission.toLocaleString()} ü™ô`, inline: true },
        { name: 'üíµ Total cobrado', value: `${totalCost.toLocaleString()} ü™ô`, inline: true },
        { name: 'Tu nuevo balance', value: `${senderData.coins.toLocaleString()} ü™ô`, inline: true },
        { name: 'Balance de ' + targetUser.username, value: `${receiverData.coins.toLocaleString()} ü™ô`, inline: true }
      )
      .setFooter({ text: 'üí° Tip: Las transferencias tienen una comisi√≥n del 5%' })
      .setTimestamp();

    await interaction.reply({ embeds: [embed] });
  }

  // WORK - Trabajar para ganar monedas
  // ========== SISTEMA DE TRABAJO COMPLETO ==========
  if (interaction.isChatInputCommand() && interaction.commandName === 'work') {
    const userData = getUser(interaction.user.id);
    const now = Date.now();

    // Verificar cooldown
    if (userData.lastWork && (now - userData.lastWork) < 7200000) { // 2 horas m√≠nimo
      const timeLeft = Math.ceil((7200000 - (now - userData.lastWork)) / 60000);
      const hours = Math.floor(timeLeft / 60);
      const mins = timeLeft % 60;
      return interaction.reply({ 
        content: `‚è∞ Ya has trabajado recientemente. Pr√≥ximo trabajo disponible en **${hours}h ${mins}m**`, 
        flags: 64 
      });
    }

    // Calcular racha de trabajo
    const lastDate = userData.lastWorkDate ? new Date(userData.lastWorkDate).toDateString() : null;
    const today = new Date().toDateString();
    const yesterday = new Date(Date.now() - 86400000).toDateString();
    
    if (lastDate === yesterday) {
      userData.workStreak += 1;
    } else if (lastDate !== today) {
      userData.workStreak = 1;
    }

    // Obtener trabajos disponibles
    const availableJobs = getJobsData(userData.workLevel);
    const xpNeeded = getXPForLevel(userData.workLevel);
    const xpProgress = Math.floor((userData.workXP / xpNeeded) * 100);

    // Crear men√∫ de selecci√≥n de trabajo
    const jobOptions = availableJobs.map(job => ({
      label: `${job.emoji} ${job.name}${job.unlockLevel > 1 ? ` (Nivel ${job.unlockLevel})` : ''}`,
      description: `Nivel requerido: ${job.unlockLevel}`,
      value: job.id
    }));

    const selectMenu = new StringSelectMenuBuilder()
      .setCustomId(`work_select_${interaction.user.id}`)
      .setPlaceholder('Selecciona tu trabajo')
      .addOptions(jobOptions);

    const embed = new EmbedBuilder()
      .setColor('#3498db')
      .setTitle('üíº Sistema de Trabajo')
      .setDescription(`**${interaction.user.username}**, elige tu trabajo para hoy`)
      .addFields(
        { name: 'üìä Tu Nivel', value: `Nivel ${userData.workLevel} (${userData.workXP}/${xpNeeded} XP - ${xpProgress}%)`, inline: true },
        { name: 'üî• Racha', value: `${userData.workStreak} d√≠as consecutivos`, inline: true },
        { name: 'üí∞ Balance', value: `${userData.coins.toLocaleString()} ü™ô`, inline: true },
        { name: 'üìù C√≥mo funciona', value: '1. Elige trabajo\n2. Selecciona turno (2h/4h/8h)\n3. Completa mini-juego\n4. Elige calidad\n5. Recibe pago + XP', inline: false }
      )
      .setFooter({ text: 'üí° Trabajos premium se desbloquean al subir de nivel' });

    await interaction.reply({ 
      embeds: [embed], 
      components: [new ActionRowBuilder().addComponents(selectMenu)],
      flags: 64 
    });
  }

  // Selecci√≥n de trabajo
  if (interaction.isStringSelectMenu() && interaction.customId.startsWith('work_select_')) {
    const userId = interaction.customId.split('_')[2];
    if (interaction.user.id !== userId) {
      return interaction.reply({ content: '‚ùå Este men√∫ no es para ti.', flags: 64 });
    }

    const jobId = interaction.values[0];
    const userData = getUser(interaction.user.id);
    const jobsData = getJobsData(userData.workLevel);
    const selectedJob = jobsData.find(j => j.id === jobId);

    // Crear botones de turno
    const shiftButtons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId(`work_shift_${userId}_${jobId}_2h`)
        .setLabel('üïê Turno 2h')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId(`work_shift_${userId}_${jobId}_4h`)
        .setLabel('üïì Turno 4h')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId(`work_shift_${userId}_${jobId}_8h`)
        .setLabel('üïó Turno 8h')
        .setStyle(ButtonStyle.Success)
    );

    const pay2h = calculatePay(80, 150, userData.workLevel, '2h');
    const pay4h = calculatePay(80, 150, userData.workLevel, '4h');
    const pay8h = calculatePay(80, 150, userData.workLevel, '8h');

    const embed = new EmbedBuilder()
      .setColor('#f39c12')
      .setTitle(`${selectedJob.emoji} ${selectedJob.name}`)
      .setDescription(`Selecciona la duraci√≥n de tu turno:`)
      .addFields(
        { name: 'ÔøΩ Turno 2 horas', value: `üí∞ ${pay2h.min}-${pay2h.max} ü™ô + 10 XP\n‚è∞ Cooldown: 2 horas`, inline: true },
        { name: 'üïì Turno 4 horas', value: `üí∞ ${pay4h.min}-${pay4h.max} ü™ô + 25 XP\n‚è∞ Cooldown: 4 horas`, inline: true },
        { name: 'üïó Turno 8 horas', value: `üí∞ ${pay8h.min}-${pay8h.max} ü™ô + 50 XP\n‚è∞ Cooldown: 8 horas`, inline: true }
      )
      .setFooter({ text: 'Turnos m√°s largos = m√°s pago pero mayor cooldown' });

    await interaction.update({ embeds: [embed], components: [shiftButtons] });
  }

  // Selecci√≥n de turno -> Mini-juego
  if (interaction.isButton() && interaction.customId.startsWith('work_shift_')) {
    const [, , userId, jobId, shift] = interaction.customId.split('_');
    if (interaction.user.id !== userId) {
      return interaction.reply({ content: '‚ùå Este bot√≥n no es para ti.', flags: 64 });
    }

    const userData = getUser(interaction.user.id);
    const jobsData = getJobsData(userData.workLevel);
    const job = jobsData.find(j => j.id === jobId);
    
    // Seleccionar pregunta aleatoria
    const question = job.questions[Math.floor(Math.random() * job.questions.length)];
    
    // Crear botones de respuestas
    const answerButtons = new ActionRowBuilder().addComponents(
      ...question.a.map((answer, idx) => 
        new ButtonBuilder()
          .setCustomId(`work_answer_${userId}_${jobId}_${shift}_${idx}_${question.correct}`)
          .setLabel(answer)
          .setStyle(ButtonStyle.Secondary)
      )
    );

    const embed = new EmbedBuilder()
      .setColor('#9b59b6')
      .setTitle(`${job.emoji} ${job.name} - Pregunta`)
      .setDescription(question.q)
      .setFooter({ text: 'Responde correctamente para maximizar tu pago' });

    await interaction.update({ embeds: [embed], components: [answerButtons] });
  }

  // Respuesta del mini-juego -> Tareas
  if (interaction.isButton() && interaction.customId.startsWith('work_answer_')) {
    const [, , userId, jobId, shift, selectedAnswer, correctAnswer] = interaction.customId.split('_');
    if (interaction.user.id !== userId) {
      return interaction.reply({ content: '‚ùå Este bot√≥n no es para ti.', flags: 64 });
    }

    const isCorrect = parseInt(selectedAnswer) === parseInt(correctAnswer);
    const userData = getUser(interaction.user.id);
    const jobsData = getJobsData(userData.workLevel);
    const job = jobsData.find(j => j.id === jobId);

    // Crear tareas progresivas
    const taskButtons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId(`work_task1_${userId}_${jobId}_${shift}_${isCorrect ? 1 : 0}_0`)
        .setLabel('ÔøΩ Tarea 1/3')
        .setStyle(ButtonStyle.Primary)
    );

    const embed = new EmbedBuilder()
      .setColor(isCorrect ? '#2ecc71' : '#e67e22')
      .setTitle(`${job.emoji} ${job.name} - ${isCorrect ? '‚úÖ ¬°Correcto!' : '‚ö†Ô∏è Respuesta incorrecta'}`)
      .setDescription(isCorrect 
        ? '¬°Excelente! Ahora completa tus tareas del turno.'
        : 'No pasa nada, a√∫n recibir√°s un pago base. Completa tus tareas.')
      .addFields(
        { name: 'üìù Progreso', value: '‚è≥ Iniciar primera tarea\nüîí Tarea 2 (Bloqueada)\nüîí Tarea 3 (Bloqueada)', inline: false }
      );

    await interaction.update({ embeds: [embed], components: [taskButtons] });
  }

  // Tareas progresivas (1/3, 2/3, 3/3)
  if (interaction.isButton() && interaction.customId.startsWith('work_task')) {
    const parts = interaction.customId.split('_');
    const taskNum = parseInt(parts[0].replace('work_task', ''));
    const [, userId, jobId, shift, correctBonus, tasksCompleted] = parts.slice(1);
    
    if (interaction.user.id !== userId) {
      return interaction.reply({ content: '‚ùå Este bot√≥n no es para ti.', flags: 64 });
    }

    const userData = getUser(interaction.user.id);
    const jobsData = getJobsData(userData.workLevel);
    const job = jobsData.find(j => j.id === jobId);
    const newTasksCompleted = parseInt(tasksCompleted) + 1;

    if (newTasksCompleted < 3) {
      // M√°s tareas pendientes
      const nextTask = taskNum + 1;
      const taskButtons = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId(`work_task${nextTask}_${userId}_${jobId}_${shift}_${correctBonus}_${newTasksCompleted}`)
          .setLabel(`üìã Tarea ${nextTask}/3`)
          .setStyle(ButtonStyle.Primary)
      );

      const progressText = [
        newTasksCompleted >= 1 ? '‚úÖ Tarea 1 completada' : '‚è≥ Tarea 1',
        newTasksCompleted >= 2 ? '‚úÖ Tarea 2 completada' : newTasksCompleted === 1 ? '‚è≥ Iniciar tarea 2' : 'üîí Tarea 2 (Bloqueada)',
        newTasksCompleted >= 3 ? '‚úÖ Tarea 3 completada' : 'üîí Tarea 3 (Bloqueada)'
      ].join('\n');

      const embed = new EmbedBuilder()
        .setColor('#3498db')
        .setTitle(`${job.emoji} ${job.name} - Tarea ${taskNum} Completada`)
        .setDescription('¬°Bien hecho! Contin√∫a con la siguiente tarea.')
        .addFields({ name: 'ÔøΩ Progreso', value: progressText, inline: false });

      await interaction.update({ embeds: [embed], components: [taskButtons] });
    } else {
      // Todas las tareas completadas -> Elegir calidad
      const qualityButtons = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId(`work_quality_${userId}_${jobId}_${shift}_${correctBonus}_fast`)
          .setLabel('‚ö° Trabajo R√°pido')
          .setStyle(ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId(`work_quality_${userId}_${jobId}_${shift}_${correctBonus}_perfect`)
          .setLabel('‚≠ê Trabajo Perfecto')
          .setStyle(ButtonStyle.Success)
      );

      const embed = new EmbedBuilder()
        .setColor('#2ecc71')
        .setTitle(`${job.emoji} ${job.name} - ‚úÖ Todas las Tareas Completadas`)
        .setDescription('¬°Excelente trabajo! Ahora elige la calidad:')
        .addFields(
          { name: '‚ö° Trabajo R√°pido', value: '‚Ä¢ 90% del pago\n‚Ä¢ Cooldown reducido (-30 min)\n‚Ä¢ +10 XP bonus', inline: true },
          { name: '‚≠ê Trabajo Perfecto', value: '‚Ä¢ 120% del pago\n‚Ä¢ Cooldown normal\n‚Ä¢ +25 XP bonus', inline: true }
        )
        .setFooter({ text: 'Elige seg√∫n tu estrategia' });

      await interaction.update({ embeds: [embed], components: [qualityButtons] });
    }
  }

  // Elecci√≥n de calidad -> Pago final
  if (interaction.isButton() && interaction.customId.startsWith('work_quality_')) {
    const [, , userId, jobId, shift, correctBonus, quality] = interaction.customId.split('_');
    if (interaction.user.id !== userId) {
      return interaction.reply({ content: '‚ùå Este bot√≥n no es para ti.', flags: 64 });
    }

    const userData = getUser(interaction.user.id);
    const jobsData = getJobsData(userData.workLevel);
    const job = jobsData.find(j => j.id === jobId);
    
    // Calcular pago
    const basePay = calculatePay(80, 150, userData.workLevel, shift);
    const randomPay = Math.floor(Math.random() * (basePay.max - basePay.min + 1)) + basePay.min;
    
    const qualityMultiplier = quality === 'fast' ? 0.9 : 1.2;
    const correctMultiplier = parseInt(correctBonus) ? 1.15 : 1;
    const streakMultiplier = userData.workStreak >= 7 ? 1.25 : userData.workStreak >= 3 ? 1.10 : 1;
    
    const finalPay = Math.floor(randomPay * qualityMultiplier * correctMultiplier * streakMultiplier);
    
    // Calcular XP
    const baseXP = { '2h': 10, '4h': 25, '8h': 50 }[shift];
    const qualityXP = quality === 'fast' ? 10 : 25;
    const totalXP = baseXP + qualityXP;
    
    // Calcular cooldown
    const baseCooldown = { '2h': 2, '4h': 4, '8h': 8 }[shift];
    const cooldownHours = quality === 'fast' ? baseCooldown - 0.5 : baseCooldown;
    const cooldownMs = cooldownHours * 3600000;
    
    // Actualizar usuario
    userData.coins += finalPay;
    userData.workXP += totalXP;
    userData.lastWork = Date.now();
    userData.lastWorkDate = new Date().toISOString();
    
    // Verificar nivel
    const xpNeeded = getXPForLevel(userData.workLevel);
    let leveledUp = false;
    if (userData.workXP >= xpNeeded) {
      userData.workLevel += 1;
      userData.workXP = 0;
      leveledUp = true;
    }
    
    updateUser(interaction.user.id, userData);

    // Embed de resultado
    const embed = new EmbedBuilder()
      .setColor('#f1c40f')
      .setTitle(`${job.emoji} ${job.name} - üéâ ¬°Turno Completado!`)
      .setDescription(leveledUp ? `üéä **¬°SUBISTE DE NIVEL!** Ahora eres Nivel ${userData.workLevel}` : `¬°Excelente trabajo ${interaction.user.username}!`)
      .addFields(
        { name: 'üí∞ Ganancia Total', value: `${finalPay.toLocaleString()} ü™ô`, inline: true },
        { name: '‚≠ê XP Ganado', value: `+${totalXP} XP`, inline: true },
        { name: 'ÔøΩ Nuevo Balance', value: `${userData.coins.toLocaleString()} ü™ô`, inline: true },
        { name: 'üìä Desglose', value: `Pago base: ${randomPay}ü™ô\n${quality === 'perfect' ? 'Calidad +20%' : 'R√°pido -10%'}\n${parseInt(correctBonus) ? 'Respuesta correcta +15%' : ''}\n${streakMultiplier > 1 ? `Racha ${userData.workStreak} d√≠as +${Math.floor((streakMultiplier - 1) * 100)}%` : ''}`, inline: false },
        { name: '‚è∞ Pr√≥ximo trabajo', value: `En ${cooldownHours} horas`, inline: true },
        { name: 'üìà Progreso', value: `Nivel ${userData.workLevel} (${userData.workXP}/${getXPForLevel(userData.workLevel)} XP)`, inline: true }
      )
      .setFooter({ text: `ÔøΩ Racha: ${userData.workStreak} d√≠as | Trabaja diario para mantenerla` })
      .setTimestamp();

    await interaction.update({ embeds: [embed], components: [] });
  }

  // BANK - Sistema bancario
  if (interaction.isChatInputCommand() && interaction.commandName === 'bank') {
    const action = interaction.options.getString('accion');
    const amount = interaction.options.getInteger('cantidad');
    const userData = getUser(interaction.user.id);

    if (action === 'balance') {
      const totalWealth = userData.coins + userData.bank;
      const embed = new EmbedBuilder()
        .setColor('#3498db')
        .setTitle('üè¶ Tu Banco Personal')
        .addFields(
          { name: 'üí∞ En mano', value: `${userData.coins.toLocaleString()} ü™ô`, inline: true },
          { name: 'üè¶ En banco', value: `${userData.bank.toLocaleString()} ü™ô`, inline: true },
          { name: 'üíé Total', value: `${totalWealth.toLocaleString()} ü™ô`, inline: true }
        )
        .setFooter({ text: 'üí° Las monedas en el banco generan 1% de inter√©s diario' })
        .setTimestamp();

      return interaction.reply({ embeds: [embed] });
    }

    if (!amount || amount <= 0) {
      return interaction.reply({ content: '‚ùå Debes especificar una cantidad v√°lida.', flags: 64 });
    }

    if (action === 'deposit') {
      if (userData.coins < amount) {
        return interaction.reply({ 
          content: `‚ùå No tienes suficientes monedas. Tienes: **${userData.coins.toLocaleString()}** ü™ô`, 
          flags: 64 
        });
      }

      userData.coins -= amount;
      userData.bank += amount;
      updateUser(interaction.user.id, userData);

      const embed = new EmbedBuilder()
        .setColor('#2ecc71')
        .setTitle('üè¶ Dep√≥sito Exitoso')
        .setDescription(`Has depositado **${amount.toLocaleString()}** ü™ô en tu banco`)
        .addFields(
          { name: 'üí∞ En mano', value: `${userData.coins.toLocaleString()} ü™ô`, inline: true },
          { name: 'üè¶ En banco', value: `${userData.bank.toLocaleString()} ü™ô`, inline: true }
        )
        .setFooter({ text: 'üí° Tu dinero en el banco est√° seguro y genera intereses' });

      await interaction.reply({ embeds: [embed] });

    } else if (action === 'withdraw') {
      if (userData.bank < amount) {
        return interaction.reply({ 
          content: `‚ùå No tienes suficientes monedas en el banco. Tienes: **${userData.bank.toLocaleString()}** ü™ô`, 
          flags: 64 
        });
      }

      userData.bank -= amount;
      userData.coins += amount;
      updateUser(interaction.user.id, userData);

      const embed = new EmbedBuilder()
        .setColor('#e74c3c')
        .setTitle('üè¶ Retiro Exitoso')
        .setDescription(`Has retirado **${amount.toLocaleString()}** ü™ô de tu banco`)
        .addFields(
          { name: 'üí∞ En mano', value: `${userData.coins.toLocaleString()} ü™ô`, inline: true },
          { name: 'üè¶ En banco', value: `${userData.bank.toLocaleString()} ü™ô`, inline: true }
        );

      await interaction.reply({ embeds: [embed] });
    }
  }

  // LOAN - Sistema de pr√©stamos
  if (interaction.isChatInputCommand() && interaction.commandName === 'loan') {
    const action = interaction.options.getString('accion');
    const amount = interaction.options.getInteger('cantidad');
    const userData = getUser(interaction.user.id);

    if (action === 'status') {
      if (!userData.loan) {
        return interaction.reply({ content: '‚úÖ No tienes ning√∫n pr√©stamo activo.', flags: 64 });
      }

      const timeLeft = userData.loan.deadline - Date.now();
      const daysLeft = Math.ceil(timeLeft / 86400000);
      
      const embed = new EmbedBuilder()
        .setColor('#e67e22')
        .setTitle('üí≥ Estado de tu Pr√©stamo')
        .addFields(
          { name: 'üí∞ Cantidad prestada', value: `${userData.loan.amount.toLocaleString()} ü™ô`, inline: true },
          { name: 'üìä Inter√©s (10%)', value: `${Math.floor(userData.loan.amount * 0.1).toLocaleString()} ü™ô`, inline: true },
          { name: 'üíµ Total a pagar', value: `${Math.floor(userData.loan.amount * 1.1).toLocaleString()} ü™ô`, inline: true },
          { name: '‚è∞ Tiempo restante', value: `${daysLeft} d√≠as`, inline: true },
          { name: 'üìã Estado', value: userData.loan.paid ? '‚úÖ Pagado' : '‚ö†Ô∏è Pendiente', inline: true }
        )
        .setFooter({ text: 'üí° Usa /loan accion:Pagar para pagar tu pr√©stamo' });

      return interaction.reply({ embeds: [embed] });
    }

    if (action === 'request') {
      if (!amount || amount < 100) {
        return interaction.reply({ content: '‚ùå El pr√©stamo m√≠nimo es de 100 monedas.', flags: 64 });
      }

      if (userData.loan && !userData.loan.paid) {
        return interaction.reply({ content: '‚ùå Ya tienes un pr√©stamo activo. P√°galo antes de pedir otro.', flags: 64 });
      }

      const maxLoan = 5000;
      if (amount > maxLoan) {
        return interaction.reply({ 
          content: `‚ùå El pr√©stamo m√°ximo es de **${maxLoan.toLocaleString()}** ü™ô`, 
          flags: 64 
        });
      }

      const deadline = Date.now() + (7 * 24 * 60 * 60 * 1000); // 7 d√≠as
      userData.loan = {
        amount,
        deadline,
        paid: false
      };
      userData.coins += amount;
      updateUser(interaction.user.id, userData);

      const interest = Math.floor(amount * 0.1);
      const totalPayback = Math.floor(amount * 1.1);

      const embed = new EmbedBuilder()
        .setColor('#2ecc71')
        .setTitle('üí≥ Pr√©stamo Aprobado')
        .setDescription(`Has recibido un pr√©stamo de **${amount.toLocaleString()}** ü™ô`)
        .addFields(
          { name: 'üí∞ Cantidad recibida', value: `${amount.toLocaleString()} ü™ô`, inline: true },
          { name: 'üìä Inter√©s (10%)', value: `${interest.toLocaleString()} ü™ô`, inline: true },
          { name: 'üíµ Total a pagar', value: `${totalPayback.toLocaleString()} ü™ô`, inline: true },
          { name: '‚è∞ Plazo', value: '7 d√≠as', inline: true },
          { name: 'üí∞ Nuevo balance', value: `${userData.coins.toLocaleString()} ü™ô`, inline: true }
        )
        .setFooter({ text: '‚ö†Ô∏è Si no pagas a tiempo, perder√°s acceso a futuros pr√©stamos' });

      await interaction.reply({ embeds: [embed] });

    } else if (action === 'pay') {
      if (!userData.loan) {
        return interaction.reply({ content: '‚ùå No tienes ning√∫n pr√©stamo que pagar.', flags: 64 });
      }

      if (userData.loan.paid) {
        return interaction.reply({ content: '‚úÖ Ya has pagado este pr√©stamo.', flags: 64 });
      }

      const payAmount = amount || Math.floor(userData.loan.amount * 1.1);
      const totalDebt = Math.floor(userData.loan.amount * 1.1);

      if (amount && amount < totalDebt) {
        return interaction.reply({ 
          content: `‚ùå Debes pagar el total: **${totalDebt.toLocaleString()}** ü™ô (o no especifiques cantidad para pagar todo)`, 
          flags: 64 
        });
      }

      if (userData.coins < totalDebt) {
        return interaction.reply({ 
          content: `‚ùå No tienes suficientes monedas. Necesitas: **${totalDebt.toLocaleString()}** ü™ô`, 
          flags: 64 
        });
      }

      userData.coins -= totalDebt;
      userData.loan.paid = true;
      updateUser(interaction.user.id, userData);

      const embed = new EmbedBuilder()
        .setColor('#2ecc71')
        .setTitle('üí≥ Pr√©stamo Pagado')
        .setDescription(`¬°Has pagado tu pr√©stamo exitosamente!`)
        .addFields(
          { name: 'üíµ Cantidad pagada', value: `${totalDebt.toLocaleString()} ü™ô`, inline: true },
          { name: 'üí∞ Nuevo balance', value: `${userData.coins.toLocaleString()} ü™ô`, inline: true }
        )
        .setFooter({ text: '‚úÖ Ahora puedes solicitar un nuevo pr√©stamo cuando lo necesites' });

      await interaction.reply({ embeds: [embed] });
    }
  }

  // DAILY-QUEST - Misiones diarias
  if (interaction.isChatInputCommand() && interaction.commandName === 'daily-quest') {
    const userData = getUser(interaction.user.id);
    const now = Date.now();
    const oneDayAgo = now - (24 * 60 * 60 * 1000);

    // Generar nuevas misiones si es necesario
    if (!userData.quests || userData.quests.length === 0 || !userData.lastQuestReset || userData.lastQuestReset < oneDayAgo) {
      userData.quests = generateDailyQuests();
      userData.lastQuestReset = now;
      updateUser(interaction.user.id, userData);
    }

    const embed = new EmbedBuilder()
      .setColor('#9b59b6')
      .setTitle('üìã Misiones Diarias')
      .setDescription('Completa misiones para ganar recompensas extra!')
      .setFooter({ text: 'üí° Las misiones se renuevan cada 24 horas' })
      .setTimestamp();

    for (let i = 0; i < userData.quests.length; i++) {
      const quest = userData.quests[i];
      const status = quest.completed ? '‚úÖ' : '‚è≥';
      const progressBar = '‚ñà'.repeat(Math.floor((quest.progress / quest.goal) * 10)) + '‚ñë'.repeat(10 - Math.floor((quest.progress / quest.goal) * 10));
      
      embed.addFields({
        name: `${status} Misi√≥n ${i + 1}`,
        value: `${quest.description}\n${progressBar} **${quest.progress}/${quest.goal}**\nüéÅ Recompensa: **${quest.reward.toLocaleString()}** ü™ô`,
        inline: false
      });
    }

    const allCompleted = userData.quests.every(q => q.completed);
    if (allCompleted && !userData.questsClaimedToday) {
      const totalReward = userData.quests.reduce((sum, q) => sum + q.reward, 0);
      userData.coins += totalReward;
      userData.questsClaimedToday = true;
      updateUser(interaction.user.id, userData);

      embed.setDescription(`üéâ **¬°Todas las misiones completadas!**\nHas ganado **${totalReward.toLocaleString()}** ü™ô`);
      embed.setColor('#2ecc71');
    }

    await interaction.reply({ embeds: [embed] });
  }

  // SPIN - Ruleta de premios
  if (interaction.isChatInputCommand() && interaction.commandName === 'spin') {
    const userData = getUser(interaction.user.id);
    const now = Date.now();
    const cooldown = 86400000; // 24 horas

    if (userData.lastSpin && (now - userData.lastSpin) < cooldown) {
      const timeLeft = cooldown - (now - userData.lastSpin);
      const hours = Math.floor(timeLeft / 3600000);
      return interaction.reply({ 
        content: `‚è∞ Ya has usado la ruleta hoy. Vuelve en **${hours}** horas.`, 
        flags: 64 
      });
    }

    const loadingEmbed = new EmbedBuilder()
      .setColor('#f39c12')
      .setTitle('üé∞ Ruleta de Premios')
      .setDescription('üé≤ **Girando la ruleta...**');

    await interaction.reply({ embeds: [loadingEmbed] });

    await new Promise(resolve => setTimeout(resolve, 2000));

    const prizes = [
      { name: 'üí∞ 50 Monedas', value: 50, emoji: 'üí∞', chance: 30 },
      { name: 'üíµ 100 Monedas', value: 100, emoji: 'üíµ', chance: 25 },
      { name: 'üíé 250 Monedas', value: 250, emoji: 'üíé', chance: 20 },
      { name: 'üåü 500 Monedas', value: 500, emoji: 'üåü', chance: 15 },
      { name: 'üëë 1000 Monedas', value: 1000, emoji: 'üëë', chance: 7 },
      { name: 'üéÅ Item Aleatorio', value: 'item', emoji: 'üéÅ', chance: 3 }
    ];

    let roll = Math.random() * 100;
    let selectedPrize = null;
    
    for (let prize of prizes) {
      if (roll <= prize.chance) {
        selectedPrize = prize;
        break;
      }
      roll -= prize.chance;
    }

    if (!selectedPrize) selectedPrize = prizes[0];

    if (selectedPrize.value === 'item') {
      const items = ['lucky_charm', 'shield', 'multiplier', 'daily_boost'];
      const randomItem = items[Math.floor(Math.random() * items.length)];
      userData.inventory.push(randomItem);
      selectedPrize.name = `üéÅ ${randomItem.replace('_', ' ')}`;
    } else {
      userData.coins += selectedPrize.value;
    }

    userData.lastSpin = now;
    updateUser(interaction.user.id, userData);

    const resultEmbed = new EmbedBuilder()
      .setColor('#2ecc71')
      .setTitle('üé∞ ¬°Resultado de la Ruleta!')
      .setDescription(`${selectedPrize.emoji} **${selectedPrize.name}**`)
      .addFields(
        { name: 'üí∞ Nuevo Balance', value: `${userData.coins.toLocaleString()} ü™ô`, inline: true },
        { name: '‚è∞ Pr√≥ximo Spin', value: 'En 24 horas', inline: true }
      )
      .setFooter({ text: 'üé∞ ¬°Vuelve ma√±ana para otro spin gratis!' })
      .setTimestamp();

    await interaction.editReply({ embeds: [resultEmbed] });
  }

  // STREAK - Ver racha de d√≠as consecutivos
  if (interaction.isChatInputCommand() && interaction.commandName === 'streak') {
    const userData = getUser(interaction.user.id);
    const now = Date.now();
    const oneDayAgo = now - (24 * 60 * 60 * 1000);
    const twoDaysAgo = now - (48 * 60 * 60 * 1000);

    // Verificar si la racha se rompi√≥
    if (userData.lastActive && userData.lastActive < twoDaysAgo) {
      userData.streak = 0;
    }

    // Incrementar racha si es un nuevo d√≠a
    if (!userData.lastActive || userData.lastActive < oneDayAgo) {
      userData.streak = (userData.streak || 0) + 1;
      userData.lastActive = now;
      
      // Recompensa por racha
      let bonus = 0;
      if (userData.streak >= 30) bonus = 500;
      else if (userData.streak >= 14) bonus = 250;
      else if (userData.streak >= 7) bonus = 100;
      else if (userData.streak >= 3) bonus = 50;

      if (bonus > 0) {
        userData.coins += bonus;
        updateUser(interaction.user.id, userData);
      }
    }

    const milestones = [
      { days: 3, reward: 50, name: 'üî• Calentando' },
      { days: 7, reward: 100, name: '‚ö° En Llamas' },
      { days: 14, reward: 250, name: 'üí´ Imparable' },
      { days: 30, reward: 500, name: 'üëë Leyenda' }
    ];

    const nextMilestone = milestones.find(m => m.days > userData.streak) || milestones[milestones.length - 1];

    const embed = new EmbedBuilder()
      .setColor('#e74c3c')
      .setTitle('üî• Tu Racha de Actividad')
      .setDescription(`Has estado activo por **${userData.streak}** d√≠as consecutivos!`)
      .addFields(
        { name: 'üìÖ D√≠as consecutivos', value: `**${userData.streak}** d√≠as`, inline: true },
        { name: 'üéØ Siguiente meta', value: `${nextMilestone.days} d√≠as\nüéÅ ${nextMilestone.reward} ü™ô`, inline: true }
      )
      .setFooter({ text: 'üí° Mant√©n tu racha activa cada d√≠a para ganar bonificaciones!' })
      .setTimestamp();

    // Agregar milestones alcanzados
    const achieved = milestones.filter(m => m.days <= userData.streak);
    if (achieved.length > 0) {
      embed.addFields({
        name: 'üèÜ Logros Desbloqueados',
        value: achieved.map(m => `${m.name} (${m.days} d√≠as)`).join('\n'),
        inline: false
      });
    }

    await interaction.reply({ embeds: [embed] });
  }

  // ========== COMANDOS DE STAFF ==========

  // ADD COINS (Solo Admin)
  if (interaction.isChatInputCommand() && interaction.commandName === 'add-coins') {
    if (!interaction.member.permissions.has(PermissionFlagsBits.Administrator)) {
      return interaction.reply({ content: '‚ùå Necesitas permisos de administrador para usar este comando.', flags: 64 });
    }

    const targetUser = interaction.options.getUser('usuario');
    const amount = interaction.options.getInteger('cantidad');

    if (amount <= 0) {
      return interaction.reply({ content: '‚ùå La cantidad debe ser mayor a 0.', flags: 64 });
    }

    const userData = getUser(targetUser.id);
    userData.coins += amount;
    updateUser(targetUser.id, userData);

    const embed = new EmbedBuilder()
      .setColor('#2ecc71')
      .setTitle('üí∞ Monedas Agregadas')
      .setDescription(`**${interaction.user.username}** agreg√≥ **${amount.toLocaleString()}** ü™ô a **${targetUser.username}**`)
      .addFields(
        { name: 'Nuevo balance', value: `${userData.coins.toLocaleString()} ü™ô`, inline: true }
      )
      .setTimestamp();

    await interaction.reply({ embeds: [embed] });
  }

  // REMOVE COINS (Solo Admin)
  if (interaction.isChatInputCommand() && interaction.commandName === 'remove-coins') {
    if (!interaction.member.permissions.has(PermissionFlagsBits.Administrator)) {
      return interaction.reply({ content: '‚ùå Necesitas permisos de administrador para usar este comando.', flags: 64 });
    }

    const targetUser = interaction.options.getUser('usuario');
    const amount = interaction.options.getInteger('cantidad');

    if (amount <= 0) {
      return interaction.reply({ content: '‚ùå La cantidad debe ser mayor a 0.', flags: 64 });
    }

    const userData = getUser(targetUser.id);
    userData.coins -= amount;
    
    // No permitir balance negativo
    if (userData.coins < 0) userData.coins = 0;
    
    updateUser(targetUser.id, userData);

    const embed = new EmbedBuilder()
      .setColor('#e74c3c')
      .setTitle('üí∏ Monedas Removidas')
      .setDescription(`**${interaction.user.username}** removi√≥ **${amount.toLocaleString()}** ü™ô de **${targetUser.username}**`)
      .addFields(
        { name: 'Nuevo balance', value: `${userData.coins.toLocaleString()} ü™ô`, inline: true }
      )
      .setTimestamp();

    await interaction.reply({ embeds: [embed] });
  }

  // ========== JUEGOS ==========

  // BLACKJACK
  if (interaction.isChatInputCommand() && interaction.commandName === 'blackjack') {
    const bet = interaction.options.getInteger('apuesta');
    const userData = getUser(interaction.user.id);

    if (bet <= 0) {
      return interaction.reply({ content: '‚ùå La apuesta debe ser mayor a 0.', flags: 64 });
    }

    if (userData.coins < bet) {
      return interaction.reply({ content: `‚ùå No tienes suficientes monedas. Tienes: **${userData.coins.toLocaleString()}** ü™ô`, flags: 64 });
    }

    // Verificar si el usuario ya tiene una partida activa
    for (let [existingGameId, game] of activeGames.entries()) {
      if (game.userId === interaction.user.id && game.game === 'blackjack') {
        return interaction.reply({ content: '‚ùå Ya tienes una partida de Blackjack en curso. Term√≠nala antes de empezar otra.', flags: 64 });
      }
    }

    // Animaci√≥n inicial
    const loadingEmbed = new EmbedBuilder()
      .setColor('#2c3e50')
      .setTitle('üÉè Blackjack')
      .setDescription('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë                                          ‚ïë\n‚ïë    üé¥ **MEZCLANDO CARTAS** üé¥   ‚ïë\n‚ïë                                          ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù')
      .addFields(
        { name: 'üí∞ Apuesta', value: `**${bet.toLocaleString()}** ü™ô`, inline: true },
        { name: 'üéØ Objetivo', value: '**21** puntos', inline: true }
      );

    try {
      await interaction.reply({ embeds: [loadingEmbed] });

      // Animaci√≥n de mezclar
      const shuffleFrames = [
        { text: 'üé¥ **MEZCLANDO**', color: '#2c3e50' },
        { text: 'üÉè **MEZCLANDO**', color: '#34495e' },
        { text: 'üé¥ **REPARTIENDO**', color: '#2c3e50' },
        { text: 'üÉè **REPARTIENDO**', color: '#34495e' }
      ];

      for (let i = 0; i < shuffleFrames.length; i++) {
        await new Promise(resolve => setTimeout(resolve, 300));
        loadingEmbed.setColor(shuffleFrames[i].color);
        loadingEmbed.setDescription(`‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë                                          ‚ïë\n‚ïë       ${shuffleFrames[i].text}      ‚ïë\n‚ïë                                          ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`);
        try {
          await interaction.editReply({ embeds: [loadingEmbed] });
        } catch (err) {
          console.error('Error editReply during blackjack animation:', err);
        }
      }
    } catch (err) {
      console.error('Blackjack initial error:', err);
      return interaction.reply({ content: '‚ùå Error al iniciar el juego. Intenta de nuevo.', flags: 64 }).catch(() => {});
    }

    // Crear baraja y repartir cartas
    const deck = [];
    const suits = ['‚ô†Ô∏è', '‚ô•Ô∏è', '‚ô¶Ô∏è', '‚ô£Ô∏è'];
    const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
    
    for (let suit of suits) {
      for (let value of values) {
        deck.push({ suit, value });
      }
    }

    // Mezclar
    for (let i = deck.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [deck[i], deck[j]] = [deck[j], deck[i]];
    }

    const playerHand = [deck.pop(), deck.pop()];
    const dealerHand = [deck.pop(), deck.pop()];

    const gameId = `${interaction.user.id}_${Date.now()}`;
    activeGames.set(gameId, { deck, playerHand, dealerHand, bet, userId: interaction.user.id, game: 'blackjack' });

    const calculateHand = (hand) => {
      let sum = 0;
      let aces = 0;
      for (let card of hand) {
        if (card.value === 'A') {
          aces++;
          sum += 11;
        } else if (['J', 'Q', 'K'].includes(card.value)) {
          sum += 10;
        } else {
          sum += parseInt(card.value);
        }
      }
      while (sum > 21 && aces > 0) {
        sum -= 10;
        aces--;
      }
      return sum;
    };

    const playerValue = calculateHand(playerHand);
    const dealerValue = calculateHand([dealerHand[0]]);

    const embed = new EmbedBuilder()
      .setColor('#2c3e50')
      .setTitle('üÉè Blackjack')
      .setDescription('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë                                        ‚ïë\n‚ïë   üéØ **Llega a 21!** üéØ   ‚ïë\n‚ïë                                        ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù')
      .addFields(
        { 
          name: 'üé¥ Tu mano', 
          value: `${playerHand.map(c => `${c.value}${c.suit}`).join(' ')} = **${playerValue}** puntos`, 
          inline: false 
        },
        { 
          name: 'üé∞ Dealer', 
          value: `${dealerHand[0].value}${dealerHand[0].suit} üÇ† = **${dealerValue}** + ?`, 
          inline: false 
        },
        { name: 'üí∞ Apuesta', value: `**${bet.toLocaleString()}** ü™ô`, inline: true },
        { name: 'üìä Estado', value: playerValue === 21 ? 'üéä **BLACKJACK!**' : playerValue > 16 ? '‚ö†Ô∏è Cuidado' : '‚úÖ Seguro', inline: true }
      )
      .setFooter({ text: `üí∞ Balance: ${userData.coins.toLocaleString()} ü™ô | üÉè Pedir carta o ‚úã Plantarse` });

    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId(`bj_hit_${gameId}`)
        .setLabel('üÉè Pedir')
        .setStyle(ButtonStyle.Success),
      new ButtonBuilder()
        .setCustomId(`bj_stand_${gameId}`)
        .setLabel('‚úã Plantarse')
        .setStyle(ButtonStyle.Danger)
    );

    if (playerValue === 21) {
      embed.setColor('#f1c40f')
        .setDescription('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë                                              ‚ïë\n‚ïë  ÔøΩ **¬°BLACKJACK!** üéä  ‚ïë\n‚ïë   **NATURAL 21**   ‚ïë\n‚ïë                                              ‚ïë\n‚ïë  üí∞ **+' + Math.floor(bet * 1.5).toLocaleString() + ' ü™ô** (2.5x)  ‚ïë\n‚ïë                                              ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
      userData.coins += Math.floor(bet * 1.5);
      userData.stats.gamesPlayed++;
      userData.stats.gamesWon++;
      userData.stats.totalWinnings += Math.floor(bet * 1.5);
      updateUser(interaction.user.id, userData);
      activeGames.delete(gameId);
      embed.setFooter({ text: `üí∞ Nuevo balance: ${userData.coins.toLocaleString()} ü™ô` });
      return interaction.editReply({ embeds: [embed] });
    }

    await interaction.editReply({ embeds: [embed], components: [buttons] });
  }

  // Botones de Blackjack
  if (interaction.isButton() && interaction.customId.startsWith('bj_')) {
    const parts = interaction.customId.split('_');
    const action = parts[1]; // 'hit' o 'stand'
    const gameId = parts.slice(2).join('_'); // resto es el gameId sin prefijo bj_
    const game = activeGames.get(gameId);

    if (!game) {
      return interaction.reply({ content: '‚ùå Este juego ya termin√≥.', flags: 64 });
    }

    if (game.userId !== interaction.user.id) {
      return interaction.reply({ content: '‚ùå Este no es tu juego.', flags: 64 });
    }

    const calculateHand = (hand) => {
      let sum = 0;
      let aces = 0;
      for (let card of hand) {
        if (card.value === 'A') {
          aces++;
          sum += 11;
        } else if (['J', 'Q', 'K'].includes(card.value)) {
          sum += 10;
        } else {
          sum += parseInt(card.value);
        }
      }
      while (sum > 21 && aces > 0) {
        sum -= 10;
        aces--;
      }
      return sum;
    };

    if (action === 'hit') {
      game.playerHand.push(game.deck.pop());
      const playerValue = calculateHand(game.playerHand);

      if (playerValue > 21) {
        const embed = new EmbedBuilder()
          .setColor('#e74c3c')
          .setTitle('üÉè Blackjack - ¬°BUST!')
          .setDescription(`‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë                                      ‚ïë\n‚ïë   üí• **¬°TE PASASTE!** üí•   ‚ïë\n‚ïë   **${playerValue}** puntos   ‚ïë\n‚ïë                                      ‚ïë\n‚ïë   **-${game.bet.toLocaleString()} ü™ô**   ‚ïë\n‚ïë                                      ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`)
          .addFields(
            { 
              name: 'üé¥ Tu mano', 
              value: `${game.playerHand.map(c => `${c.value}${c.suit}`).join(' ')} = **${playerValue}** üí•`, 
              inline: false 
            },
            { 
              name: 'üé∞ Dealer ten√≠a', 
              value: `${game.dealerHand.map(c => `${c.value}${c.suit}`).join(' ')} = **${calculateHand(game.dealerHand)}**`, 
              inline: false 
            }
          );

        const userData = getUser(interaction.user.id);
        userData.coins -= game.bet;
        userData.stats.gamesPlayed++;
        userData.stats.gamesLost++;
        userData.stats.totalLosses += game.bet;
        updateUser(interaction.user.id, userData);
        activeGames.delete(gameId);

        embed.setFooter({ text: `üí∞ Nuevo balance: ${userData.coins.toLocaleString()} ü™ô` });
        await interaction.update({ embeds: [embed], components: [] });
      } else {
        const statusMsg = playerValue === 21 ? 'üéä **¬°BLACKJACK!**' : playerValue >= 19 ? 'üî• **Excelente mano**' : playerValue >= 17 ? '‚ö†Ô∏è **Arriesgado**' : '‚úÖ **Seguro**';
        
        const embed = new EmbedBuilder()
          .setColor(playerValue >= 17 ? '#e67e22' : '#2c3e50')
          .setTitle('üÉè Blackjack')
          .setDescription(`‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë                                        ‚ïë\n‚ïë   ${statusMsg}   ‚ïë\n‚ïë                                        ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`)
          .addFields(
            { 
              name: 'üé¥ Tu mano', 
              value: `${game.playerHand.map(c => `${c.value}${c.suit}`).join(' ')} = **${playerValue}**`, 
              inline: false 
            },
            { 
              name: 'ÔøΩ Tu mano', 
              value: `${game.playerHand.map(c => `${c.value}${c.suit}`).join(' ')} = **${playerValue}** puntos`, 
              inline: false 
            },
            { 
              name: 'ÔøΩüé∞ Dealer', 
              value: `${game.dealerHand[0].value}${game.dealerHand[0].suit} üÇ† = **?**`, 
              inline: false 
            },
            { name: 'üí∞ Apuesta', value: `**${game.bet.toLocaleString()}** ü™ô`, inline: true },
            { name: 'üìä Riesgo', value: statusMsg, inline: true }
          )
          .setFooter({ text: 'üÉè Pedir otra carta o ‚úã Plantarse' });

        const buttons = new ActionRowBuilder().addComponents(
          new ButtonBuilder()
            .setCustomId(`bj_hit_${gameId}`)
            .setLabel('üÉè Pedir')
            .setStyle(ButtonStyle.Success),
          new ButtonBuilder()
            .setCustomId(`bj_stand_${gameId}`)
            .setLabel('‚úã Plantarse')
            .setStyle(ButtonStyle.Danger)
        );

        await interaction.update({ embeds: [embed], components: [buttons] });
      }
    } else if (action === 'stand') {
      // Animaci√≥n del dealer revelando y jugando
      const frames = [
        { emoji: 'üé¥', text: 'Revelando carta del dealer...', color: '#3498db' },
        { emoji: 'üÉè', text: 'Dealer jugando su turno...', color: '#9b59b6' },
        { emoji: 'üé∞', text: 'Evaluando resultado...', color: '#e67e22' }
      ];

      await interaction.update({ 
        embeds: [new EmbedBuilder()
          .setColor(frames[0].color)
          .setTitle('üÉè Blackjack')
          .setDescription(`${frames[0].emoji} **${frames[0].text}**`)
        ], 
        components: [] 
      });

      for (let i = 1; i < frames.length; i++) {
        await new Promise(resolve => setTimeout(resolve, 500));
        await interaction.editReply({
          embeds: [new EmbedBuilder()
            .setColor(frames[i].color)
            .setTitle('üÉè Blackjack')
            .setDescription(`${frames[i].emoji} **${frames[i].text}**`)
          ]
        });
      }

      await new Promise(resolve => setTimeout(resolve, 500));

      let dealerValue = calculateHand(game.dealerHand);
      
      while (dealerValue < 17) {
        game.dealerHand.push(game.deck.pop());
        dealerValue = calculateHand(game.dealerHand);
      }

      const playerValue = calculateHand(game.playerHand);
      const userData = getUser(interaction.user.id);
      let result = '';
      let resultBox = '';
      let color = '#95a5a6';
      let icon = 'ü§ù';

      if (dealerValue > 21 || playerValue > dealerValue) {
        icon = 'üéâ';
        resultBox = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë   ÔøΩ ¬°VICTORIA! üéä    ‚ïë
‚ïë                       ‚ïë
‚ïë   Ganancia: +${game.bet.toLocaleString()} ü™ô   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`;
        result = `${icon} **¬°Ganaste!**\n\n${resultBox}`;
        userData.coins += game.bet;
        userData.stats.gamesWon++;
        userData.stats.totalWinnings += game.bet;
        color = '#2ecc71';
      } else if (playerValue === dealerValue) {
        icon = 'ü§ù';
        resultBox = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë      ü§ù EMPATE ü§ù     ‚ïë
‚ïë                       ‚ïë
‚ïë   Apuesta devuelta    ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`;
        result = `${icon} **Empate**\n\n${resultBox}`;
        color = '#f39c12';
      } else {
        icon = 'üíî';
        resultBox = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë    üíî DERROTA üíî      ‚ïë
‚ïë                       ‚ïë
‚ïë   P√©rdida: -${game.bet.toLocaleString()} ü™ô  ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`;
        result = `${icon} **Perdiste**\n\n${resultBox}`;
        userData.coins -= game.bet;
        userData.stats.gamesLost++;
        userData.stats.totalLosses += game.bet;
        color = '#e74c3c';
      }

      userData.stats.gamesPlayed++;
      updateUser(interaction.user.id, userData);

      const embed = new EmbedBuilder()
        .setColor(color)
        .setTitle('üÉè Blackjack - Resultado Final')
        .setDescription(result)
        .addFields(
          { 
            name: 'üé¥ Tu mano', 
            value: `${game.playerHand.map(c => `${c.value}${c.suit}`).join(' ')} = **${playerValue}** puntos`, 
            inline: true 
          },
          { 
            name: 'üé∞ Dealer', 
            value: `${game.dealerHand.map(c => `${c.value}${c.suit}`).join(' ')} = **${dealerValue}** puntos`, 
            inline: true 
          }
        )
        .setFooter({ text: `üí∞ Balance: ${userData.coins.toLocaleString()} ü™ô` });

      activeGames.delete(gameId);
      await interaction.editReply({ embeds: [embed], components: [] });
    }
  }

  // COINFLIP
  if (interaction.isChatInputCommand() && interaction.commandName === 'coinflip') {
    const bet = interaction.options.getInteger('apuesta');
    const choice = interaction.options.getString('eleccion');
    const userData = getUser(interaction.user.id);

    if (bet <= 0) {
      return interaction.reply({ content: '‚ùå La apuesta debe ser mayor a 0.', flags: 64 });
    }

    if (userData.coins < bet) {
      return interaction.reply({ content: `‚ùå No tienes suficientes monedas. Tienes: **${userData.coins.toLocaleString()}** ü™ô`, flags: 64 });
    }

    // Evitar que el usuario abra m√∫ltiples coinflips simult√°neos
    const gameId = `coinflip_${interaction.user.id}_${Date.now()}`;
    for (const g of activeGames.values()) {
      if (g.userId === interaction.user.id && g.game === 'coinflip') {
        return interaction.reply({ content: '‚ùå Ya tienes un coinflip en curso. Espera a que termine.', flags: 64 });
      }
    }

    activeGames.set(gameId, { userId: interaction.user.id, game: 'coinflip', bet });

    // Animaci√≥n mejorada de moneda girando
    const loadingEmbed = new EmbedBuilder()
      .setColor('#f39c12')
      .setTitle('ü™ô Coinflip')
      .setDescription('‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì\n‚îÉ                                        ‚îÉ\n‚îÉ          ü™ô **LANZANDO**      ‚îÉ\n‚îÉ                                        ‚îÉ\n‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ')
      .addFields(
        { name: 'üéØ Tu elecci√≥n', value: choice === 'cara' ? '‚ú® **CARA**' : 'üíÄ **CRUZ**', inline: true },
        { name: 'üí∞ Apuesta', value: `**${bet.toLocaleString()}** ü™ô`, inline: true }
      );

    try {
      await interaction.reply({ embeds: [loadingEmbed] });

      // Animaci√≥n m√°s elaborada
      const frames = [
        { emoji: 'ü™ô', text: '**GIRANDO**', color: '#f39c12' },
        { emoji: 'üí´', text: '**GIRANDO**', color: '#e67e22' },
        { emoji: '‚ú®', text: '**GIRANDO**', color: '#d35400' },
        { emoji: 'üåü', text: '**GIRANDO**', color: '#f39c12' },
        { emoji: 'üí´', text: '**GIRANDO**', color: '#e67e22' },
        { emoji: '‚≠ê', text: '**CAYENDO**', color: '#f1c40f' },
        { emoji: 'ü™ô', text: '**CAYENDO**', color: '#f39c12' }
      ];

      for (let i = 0; i < frames.length; i++) {
        // peque√±o delay entre frames
        await new Promise(resolve => setTimeout(resolve, 300));
        loadingEmbed.setColor(frames[i].color);
        loadingEmbed.setDescription(`‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì\n‚îÉ                                        ‚îÉ\n‚îÉ        ${frames[i].emoji} ${frames[i].text}      ‚îÉ\n‚îÉ                                        ‚îÉ\n‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ`);
        try {
          await interaction.editReply({ embeds: [loadingEmbed] });
        } catch (err) {
          // No bloqueamos la animaci√≥n si falla un edit (rate limit u otro)
          console.error('Error editReply during coinflip animation:', err);
        }
      }

      const result = Math.random() < 0.5 ? 'cara' : 'cruz';
      const won = result === choice;

      const embed = new EmbedBuilder()
        .setTitle('ü™ô Coinflip - Resultado')
        .addFields(
          { name: 'üéØ Tu elecci√≥n', value: choice === 'cara' ? '‚ú® **CARA**' : 'üíÄ **CRUZ**', inline: true },
          { name: 'üé≤ Cay√≥ en', value: result === 'cara' ? '‚ú® **CARA**' : 'üíÄ **CRUZ**', inline: true },
          { name: 'üí∞ Apuesta', value: `**${bet.toLocaleString()}** ü™ô`, inline: false }
        );

      if (won) {
        userData.coins += bet;
        userData.stats.gamesWon++;
        userData.stats.totalWinnings += bet;
        embed.setColor('#2ecc71')
          .setDescription(`‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë   üéâ **¬°GANASTE!** üéâ    ‚ïë\n‚ïë  **+${bet.toLocaleString()} ü™ô**  ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`);
      } else {
        userData.coins -= bet;
        userData.stats.gamesLost++;
        userData.stats.totalLosses += bet;
        embed.setColor('#e74c3c')
          .setDescription(`‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë   ‚ùå **PERDISTE** ‚ùå     ‚ïë\n‚ïë  **-${bet.toLocaleString()} ü™ô**  ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`);
      }

      userData.stats.gamesPlayed++;
      updateUser(interaction.user.id, userData);

      embed.setFooter({ text: `üí∞ Nuevo balance: ${userData.coins.toLocaleString()} ü™ô` });
      await interaction.editReply({ embeds: [embed] });
    } catch (err) {
      console.error('Coinflip error:', err);
      try { await interaction.followUp({ content: '‚ùå Ocurri√≥ un error ejecutando el coinflip. Intenta de nuevo.', flags: 64 }); } catch(e){}
    } finally {
      activeGames.delete(gameId);
    }
  }

  // DADOS
  if (interaction.isChatInputCommand() && interaction.commandName === 'dice') {
    const bet = interaction.options.getInteger('apuesta');
    const userData = getUser(interaction.user.id);

    if (bet <= 0) {
      return interaction.reply({ content: '‚ùå La apuesta debe ser mayor a 0.', flags: 64 });
    }

    if (userData.coins < bet) {
      return interaction.reply({ content: `‚ùå No tienes suficientes monedas. Tienes: **${userData.coins.toLocaleString()}** ü™ô`, flags: 64 });
    }

    // Evitar que el usuario abra m√∫ltiples juegos de dados simult√°neos
    const gameId = `dice_${interaction.user.id}_${Date.now()}`;
    for (const g of activeGames.values()) {
      if (g.userId === interaction.user.id && g.game === 'dice') {
        return interaction.reply({ content: '‚ùå Ya tienes un juego de dados en curso. Espera a que termine.', flags: 64 });
      }
    }

    activeGames.set(gameId, { userId: interaction.user.id, game: 'dice', bet });

    // Animaci√≥n mejorada de dados
    const loadingEmbed = new EmbedBuilder()
      .setColor('#e74c3c')
      .setTitle('üé≤ Dados')
      .setDescription('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë                                      ‚ïë\n‚ïë      üé≤ **LANZANDO** üé≤     ‚ïë\n‚ïë                                      ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù')
      .addFields(
        { name: 'üí∞ Apuesta', value: `**${bet.toLocaleString()}** ü™ô`, inline: true },
        { name: 'üéØ Objetivo', value: '**12** = 3x üíé\n**10-11** = 2x ‚≠ê\n**7-9** = Empate ü§ù', inline: true }
      );

    try {
      await interaction.reply({ embeds: [loadingEmbed] });

      // Animaci√≥n m√°s elaborada de dados girando
      const diceFrames = [
        { dice: '‚öÄ ‚öÄ', text: '**GIRANDO**', color: '#e74c3c' },
        { dice: '‚öÅ ‚öÇ', text: '**GIRANDO**', color: '#c0392b' },
        { dice: '‚öÉ ‚öÑ', text: '**GIRANDO**', color: '#e74c3c' },
        { dice: '‚öÖ ‚öÄ', text: '**GIRANDO**', color: '#c0392b' },
        { dice: '‚öÅ ‚öÉ', text: '**RODANDO**', color: '#e67e22' },
        { dice: '‚öÑ ‚öÖ', text: '**RODANDO**', color: '#d35400' },
        { dice: '‚öÇ ‚öÅ', text: '**RODANDO**', color: '#e67e22' },
        { dice: '‚öÖ ‚öÉ', text: '**CAYENDO**', color: '#f39c12' }
      ];

      for (let i = 0; i < diceFrames.length; i++) {
        await new Promise(resolve => setTimeout(resolve, 250));
        loadingEmbed.setColor(diceFrames[i].color);
        loadingEmbed.setDescription(`‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë                                      ‚ïë\n‚ïë   ${diceFrames[i].dice} ${diceFrames[i].text}   ‚ïë\n‚ïë                                      ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`);
        try {
          await interaction.editReply({ embeds: [loadingEmbed] });
        } catch (err) {
          console.error('Error editReply during dice animation:', err);
        }
      }

    const dice1 = Math.floor(Math.random() * 6) + 1;
    const dice2 = Math.floor(Math.random() * 6) + 1;
    const total = dice1 + dice2;

    const diceEmojis = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'];

    let winnings = 0;
    let result = '';
    let color = '#e74c3c';
    let resultBox = '';

    if (total === 12) {
      winnings = bet * 3;
      result = `ÔøΩ **¬°DOBLE 6!** üéä\nüíé **JACKPOT** üíé`;
      color = '#f1c40f';
      resultBox = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë  üéä **¬°DOBLE 6!** üéä   ‚ïë\n‚ïë   **+${winnings.toLocaleString()} ü™ô** (3x)   ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`;
    } else if (total >= 10) {
      winnings = bet * 2;
      result = `‚ú® **¬°EXCELENTE!** ‚ú®`;
      color = '#2ecc71';
      resultBox = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë  ‚ú® **¬°GANASTE!** ‚ú®    ‚ïë\n‚ïë   **+${winnings.toLocaleString()} ü™ô** (2x)   ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`;
    } else if (total >= 7) {
      winnings = bet;
      result = `ü§ù **EMPATE** ü§ù`;
      color = '#95a5a6';
      resultBox = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë    ü§ù **EMPATE** ü§ù     ‚ïë\n‚ïë  Apuesta devuelta   ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`;
    } else {
      winnings = -bet;
      result = `üíî **MUY BAJO** üíî`;
      color = '#e74c3c';
      resultBox = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë   ‚ùå **PERDISTE** ‚ùå   ‚ïë\n‚ïë   **-${bet.toLocaleString()} ü™ô**   ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`;
    }

      userData.coins += winnings;
      userData.stats.gamesPlayed++;
      
      if (winnings > 0) {
        userData.stats.gamesWon++;
        userData.stats.totalWinnings += winnings;
      } else if (winnings < 0) {
        userData.stats.gamesLost++;
        userData.stats.totalLosses += Math.abs(winnings);
      }

      updateUser(interaction.user.id, userData);

      const embed = new EmbedBuilder()
        .setColor(color)
        .setTitle('üé≤ Dados - Resultado')
        .setDescription(resultBox)
        .addFields(
          { name: 'üé≤ Dados', value: `${diceEmojis[dice1-1]} ${diceEmojis[dice2-1]}`, inline: true },
          { name: 'üìä Total', value: `**${total}** puntos`, inline: true },
          { name: 'üí∞ Apuesta', value: `**${bet.toLocaleString()}** ü™ô`, inline: true }
        )
        .setFooter({ text: `üí∞ Nuevo balance: ${userData.coins.toLocaleString()} ü™ô` });

      await interaction.editReply({ embeds: [embed] });
    } catch (err) {
      console.error('Dice error:', err);
      try { await interaction.followUp({ content: '‚ùå Ocurri√≥ un error ejecutando los dados. Intenta de nuevo.', flags: 64 }); } catch(e){}
    } finally {
      activeGames.delete(gameId);
    }
  }

  // RULETA
  if (interaction.isChatInputCommand() && interaction.commandName === 'roulette') {
    const bet = interaction.options.getInteger('apuesta');
    const choice = interaction.options.getString('eleccion');
    const userData = getUser(interaction.user.id);

    if (bet <= 0) {
      return interaction.reply({ content: '‚ùå La apuesta debe ser mayor a 0.', flags: 64 });
    }

    if (userData.coins < bet) {
      return interaction.reply({ content: `‚ùå No tienes suficientes monedas. Tienes: **${userData.coins.toLocaleString()}** ü™ô`, flags: 64 });
    }

    // Animaci√≥n de ruleta profesional
    const loadingEmbed = new EmbedBuilder()
      .setColor('#9b59b6')
      .setTitle('üé∞ RULETA DE LA FORTUNA')
      .setDescription('‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì\n‚îÉ                                            ‚îÉ\n‚îÉ    ÔøΩ **GIRANDO RULETA** üé∞   ‚îÉ\n‚îÉ                                            ‚îÉ\n‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ')
      .addFields(
        { name: 'üéØ Tu apuesta', value: choice === 'rojo' ? 'üî¥ **ROJO**' : choice === 'negro' ? '‚ö´ **NEGRO**' : `üéØ **N√∫mero ${choice}**`, inline: true },
        { name: 'üí∞ Cantidad', value: `**${bet.toLocaleString()}** ü™ô`, inline: true }
      );

    await interaction.reply({ embeds: [loadingEmbed] });

    // Animaci√≥n m√°s elaborada de ruleta
    const spinFrames = [
      { num: '36', color: 'üî¥', bgcolor: '#e74c3c' },
      { num: '13', color: '‚ö´', bgcolor: '#2c3e50' },
      { num: '27', color: 'üî¥', bgcolor: '#e74c3c' },
      { num: '6', color: '‚ö´', bgcolor: '#2c3e50' },
      { num: '34', color: 'üî¥', bgcolor: '#e74c3c' },
      { num: '17', color: '‚ö´', bgcolor: '#2c3e50' },
      { num: '25', color: 'üî¥', bgcolor: '#e74c3c' },
      { num: '2', color: '‚ö´', bgcolor: '#2c3e50' },
      { num: '21', color: 'üî¥', bgcolor: '#e74c3c' },
      { num: '4', color: '‚ö´', bgcolor: '#2c3e50' }
    ];

    for (let i = 0; i < spinFrames.length; i++) {
      await new Promise(resolve => setTimeout(resolve, 200 + (i * 30))); // Va m√°s lento al final
      loadingEmbed.setColor(spinFrames[i].bgcolor);
      loadingEmbed.setDescription(`‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì\n‚îÉ                                            ‚îÉ\n‚îÉ       ${spinFrames[i].color} **${spinFrames[i].num}** üé∞       ‚îÉ\n‚îÉ                                            ‚îÉ\n‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ`);
      await interaction.editReply({ embeds: [loadingEmbed] });
    }

    const number = Math.floor(Math.random() * 37); // 0-36
    const isRed = [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36].includes(number);
    const color = number === 0 ? 'verde' : isRed ? 'rojo' : 'negro';

    let winnings = 0;
    let won = false;

    if (choice === number.toString()) {
      winnings = bet * 36;
      won = true;
    } else if (choice === 'rojo' && color === 'rojo') {
      winnings = bet * 2;
      won = true;
    } else if (choice === 'negro' && color === 'negro') {
      winnings = bet * 2;
      won = true;
    } else {
      winnings = -bet;
    }

    let resultBox = '';
    let finalColor = '#e74c3c';

    if (choice === number.toString() && won) {
      resultBox = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë  üéä **¬°N√öMERO EXACTO!** üéä  ‚ïë\n‚ïë    üíé **MEGA PREMIO** üíé    ‚ïë\n‚ïë     **+${winnings.toLocaleString()} ü™ô** (36x)     ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`;
      finalColor = '#f1c40f';
    } else if (won) {
      resultBox = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë   üéâ **¬°GANASTE!** üéâ   ‚ïë\n‚ïë   **+${winnings.toLocaleString()} ü™ô** (2x)   ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`;
      finalColor = '#2ecc71';
    } else {
      resultBox = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë   ‚ùå **PERDISTE** ‚ùå   ‚ïë\n‚ïë    **-${bet.toLocaleString()} ü™ô**    ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`;
      finalColor = '#e74c3c';
    }

    const embed = new EmbedBuilder()
      .setColor(finalColor)
      .setTitle('üé∞ Ruleta - Resultado')
      .setDescription(resultBox)
      .addFields(
        { name: 'üéØ Tu apuesta', value: choice === 'rojo' ? 'üî¥ **ROJO**' : choice === 'negro' ? '‚ö´ **NEGRO**' : `üéØ **#${choice}**`, inline: true },
        { name: 'üé≤ Cay√≥ en', value: `${color === 'rojo' ? 'üî¥' : color === 'negro' ? '‚ö´' : 'üü¢'} **${number}** (${color.toUpperCase()})`, inline: true },
        { name: 'üí∞ Apuesta', value: `**${bet.toLocaleString()}** ü™ô`, inline: false }
      );

    if (won) {
      userData.coins += winnings;
      userData.stats.gamesWon++;
      userData.stats.totalWinnings += winnings;
    } else {
      userData.coins += winnings;
      userData.stats.gamesLost++;
      userData.stats.totalLosses += Math.abs(winnings);
    }

    userData.stats.gamesPlayed++;
    updateUser(interaction.user.id, userData);

    embed.setFooter({ text: `üí∞ Nuevo balance: ${userData.coins.toLocaleString()} ü™ô | Color: 2x | N√∫mero exacto: 36x` });
    await interaction.editReply({ embeds: [embed] });
  }

  // PIEDRA PAPEL TIJERA
  if (interaction.isChatInputCommand() && interaction.commandName === 'rps') {
    const bet = interaction.options.getInteger('apuesta');
    const choice = interaction.options.getString('eleccion');
    const userData = getUser(interaction.user.id);

    if (bet <= 0) {
      return interaction.reply({ content: '‚ùå La apuesta debe ser mayor a 0.', flags: 64 });
    }

    if (userData.coins < bet) {
      return interaction.reply({ content: `‚ùå No tienes suficientes monedas. Tienes: **${userData.coins.toLocaleString()}** ü™ô`, flags: 64 });
    }

    const emojis = {
      piedra: 'ü™®',
      papel: 'üìÑ',
      tijera: '‚úÇÔ∏è'
    };

    // Animaci√≥n de duelo
    const loadingEmbed = new EmbedBuilder()
      .setColor('#3498db')
      .setTitle('‚úä‚úã‚úåÔ∏è Piedra, Papel o Tijera')
      .setDescription('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë                                        ‚ïë\n‚ïë      ‚öîÔ∏è **PREPARANDO** ‚öîÔ∏è     ‚ïë\n‚ïë                                        ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù')
      .addFields(
        { name: 'üéØ Tu elecci√≥n', value: `${emojis[choice]} **${choice.toUpperCase()}**`, inline: true },
        { name: 'üí∞ Apuesta', value: `**${bet.toLocaleString()}** ü™ô`, inline: true }
      );

    await interaction.reply({ embeds: [loadingEmbed] });

    // Animaci√≥n de cuenta regresiva
    const countFrames = [
      { text: '**3...**', color: '#e74c3c' },
      { text: '**2...**', color: '#f39c12' },
      { text: '**1...**', color: '#f1c40f' },
      { text: '**¬°YA!**', color: '#2ecc71' }
    ];

    for (let i = 0; i < countFrames.length; i++) {
      await new Promise(resolve => setTimeout(resolve, 500));
      loadingEmbed.setColor(countFrames[i].color);
      loadingEmbed.setDescription(`‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë                                        ‚ïë\n‚ïë       ${countFrames[i].text}       ‚ïë\n‚ïë                                        ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`);
      await interaction.editReply({ embeds: [loadingEmbed] });
    }

    const options = ['piedra', 'papel', 'tijera'];
    const botChoice = options[Math.floor(Math.random() * 3)];

    let result = '';
    let winnings = 0;
    let color = '#95a5a6';
    let resultBox = '';

    if (choice === botChoice) {
      result = 'ü§ù **EMPATE**';
      color = '#f39c12';
      resultBox = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë    ü§ù **EMPATE** ü§ù     ‚ïë\n‚ïë  Apuesta devuelta   ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`;
    } else if (
      (choice === 'piedra' && botChoice === 'tijera') ||
      (choice === 'papel' && botChoice === 'piedra') ||
      (choice === 'tijera' && botChoice === 'papel')
    ) {
      winnings = bet * 2;
      userData.coins += bet;
      userData.stats.gamesWon++;
      userData.stats.totalWinnings += bet;
      result = `üéâ **¬°VICTORIA!**`;
      color = '#2ecc71';
      resultBox = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë  üéâ **¬°GANASTE!** üéâ   ‚ïë\n‚ïë   **+${bet.toLocaleString()} ü™ô** (2x)   ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`;
    } else {
      winnings = -bet;
      userData.coins -= bet;
      userData.stats.gamesLost++;
      userData.stats.totalLosses += bet;
      result = `‚ùå **DERROTA**`;
      color = '#e74c3c';
      resultBox = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë   ‚ùå **PERDISTE** ‚ùå   ‚ïë\n‚ïë    **-${bet.toLocaleString()} ü™ô**    ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`;
    }

    userData.stats.gamesPlayed++;
    updateUser(interaction.user.id, userData);

    const embed = new EmbedBuilder()
      .setColor(color)
      .setTitle('‚úä‚úã‚úåÔ∏è Piedra, Papel o Tijera - Resultado')
      .setDescription(resultBox)
      .addFields(
        { name: 'üéØ T√∫', value: `${emojis[choice]} **${choice.toUpperCase()}**`, inline: true },
        { name: '‚ö° VS', value: 'üí•', inline: true },
        { name: 'ü§ñ Bot', value: `${emojis[botChoice]} **${botChoice.toUpperCase()}**`, inline: true }
      )
      .setFooter({ text: `üí∞ Nuevo balance: ${userData.coins.toLocaleString()} ü™ô` });

    await interaction.editReply({ embeds: [embed] });
  }

  // ADIVINA EL N√öMERO
  if (interaction.isChatInputCommand() && interaction.commandName === 'guess') {
    const bet = interaction.options.getInteger('apuesta');
    const userData = getUser(interaction.user.id);

    if (bet <= 0) {
      return interaction.reply({ content: '‚ùå La apuesta debe ser mayor a 0.', flags: 64 });
    }

    if (userData.coins < bet) {
      return interaction.reply({ content: `‚ùå No tienes suficientes monedas. Tienes: **${userData.coins.toLocaleString()}** ü™ô`, flags: 64 });
    }

    const targetNumber = Math.floor(Math.random() * 100) + 1;
    const gameId = `guess_${interaction.user.id}_${Date.now()}`;
    
    activeGames.set(gameId, {
      targetNumber,
      attempts: 0,
      maxAttempts: 5,
      bet,
      userId: interaction.user.id
    });

    const embed = new EmbedBuilder()
      .setColor('#3498db')
      .setTitle('üî¢ Adivina el N√∫mero')
      .setDescription('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë                                            ‚ïë\n‚ïë  üéØ **PENSANDO UN N√öMERO** üéØ  ‚ïë\n‚ïë      **Del 1 al 100**      ‚ïë\n‚ïë                                            ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\nüéÆ Tienes **5 intentos** para adivinarlo.\nüí° Cuantos menos intentos uses, **¬°M√ÅS GANAS!**\n\n‚úçÔ∏è **Escribe un n√∫mero en el chat**')
      .addFields(
        { name: 'üí∞ Apuesta', value: `**${bet.toLocaleString()}** ü™ô`, inline: true },
        { name: 'üéØ Intentos', value: '**5** restantes', inline: true },
        { name: 'üèÜ Multiplicadores', value: 'ü•á **1 intento:** 5x\nü•à **2 intentos:** 4x\nü•â **3 intentos:** 3x\nüéñÔ∏è **4 intentos:** 2x\n‚≠ê **5 intentos:** 1x', inline: false }
      )
      .setFooter({ text: 'üí≠ Piensa bien... cada intento cuenta!' });

    await interaction.reply({ embeds: [embed] });
  }

  // HIGH OR LOW
  if (interaction.isChatInputCommand() && interaction.commandName === 'highlow') {
    const bet = interaction.options.getInteger('apuesta');
    const userData = getUser(interaction.user.id);

    if (bet <= 0) {
      return interaction.reply({ content: '‚ùå La apuesta debe ser mayor a 0.', flags: 64 });
    }

    if (userData.coins < bet) {
      return interaction.reply({ content: `‚ùå No tienes suficientes monedas. Tienes: **${userData.coins.toLocaleString()}** ü™ô`, flags: 64 });
    }

    const currentNumber = Math.floor(Math.random() * 100) + 1;
    const gameId = `${interaction.user.id}_${Date.now()}`;
    
    activeGames.set(gameId, {
      currentNumber,
      streak: 0,
      bet,
      userId: interaction.user.id
    });

    const embed = new EmbedBuilder()
      .setColor('#9b59b6')
      .setTitle('üìä Higher or Lower')
      .setDescription(`üé≤ **N√∫mero actual: ${currentNumber}**\n\n‚ùì **¬øEl siguiente ser√° mayor o menor?**\n\nüî• Construye rachas para ganar m√°s!\nüí∞ Puedes cobrar en cualquier momento`)
      .addFields(
        { name: 'üí∞ Apuesta', value: `${bet.toLocaleString()} ü™ô`, inline: true },
        { name: 'üî• Racha', value: '**0**', inline: true },
        { name: 'üíé Multiplicador', value: '**1x**', inline: true },
        { name: 'üèÜ Premios', value: '**Racha 5:** 10x üíé\n**Racha 3:** 5x ‚≠ê\n**Racha 1:** 2x ‚ú®', inline: false }
      )
      .setFooter({ text: 'üéÆ ¬°Elige sabiamente!' });

    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId(`hl_higher_${gameId}`)
        .setLabel('‚¨ÜÔ∏è Mayor')
        .setStyle(ButtonStyle.Success),
      new ButtonBuilder()
        .setCustomId(`hl_lower_${gameId}`)
        .setLabel('‚¨áÔ∏è Menor')
        .setStyle(ButtonStyle.Danger),
      new ButtonBuilder()
        .setCustomId(`hl_cashout_${gameId}`)
        .setLabel('üí∞ Cobrar')
        .setStyle(ButtonStyle.Primary)
        .setDisabled(true)
    );

    await interaction.reply({ embeds: [embed], components: [buttons] });
  }

  // Botones de Higher or Lower
  if (interaction.isButton() && interaction.customId.startsWith('hl_')) {
    const parts = interaction.customId.split('_');
    const action = parts[1]; // 'higher', 'lower', o 'cashout'
    const gameId = parts.slice(2).join('_'); // resto es el gameId
    const game = activeGames.get(gameId);

    if (!game) {
      return interaction.reply({ content: '‚ùå Este juego ya termin√≥.', flags: 64 });
    }

    if (game.userId !== interaction.user.id) {
      return interaction.reply({ content: '‚ùå Este no es tu juego.', flags: 64 });
    }

    if (action === 'cashout') {
      const multipliers = [0, 2, 3, 5, 7, 10];
      const multiplier = multipliers[Math.min(game.streak, 5)];
      const winnings = game.bet * multiplier;

      const userData = getUser(interaction.user.id);
      userData.coins += winnings - game.bet;
      userData.stats.gamesPlayed++;
      userData.stats.gamesWon++;
      userData.stats.totalWinnings += winnings - game.bet;
      updateUser(interaction.user.id, userData);

      const streakMedals = ['', '‚ú®', '‚≠ê', 'üåü', 'üí´', 'üíé'];
      const medal = streakMedals[Math.min(game.streak, 5)];

      const embed = new EmbedBuilder()
        .setColor('#2ecc71')
        .setTitle('üìä Higher or Lower - ¬°COBRADO!')
        .setDescription(`‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë                                              ‚ïë\n‚ïë  ${medal} **¬°PREMIO COBRADO!** ${medal}  ‚ïë\n‚ïë                                              ‚ïë\n‚ïë  üí∞ **+${(winnings - game.bet).toLocaleString()} ü™ô**  ‚ïë\n‚ïë                                              ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`)
        .addFields(
          { name: 'üî• Racha final', value: `**${game.streak}** ${medal}`, inline: true },
          { name: 'üíé Multiplicador', value: `**${multiplier}x**`, inline: true },
          { name: 'üèÜ Ganancia', value: `**${(winnings - game.bet).toLocaleString()}** ü™ô`, inline: true }
        )
        .setFooter({ text: `üí∞ Nuevo balance: ${userData.coins.toLocaleString()} ü™ô | ¬°Excelente decisi√≥n!` });

      activeGames.delete(gameId);
      await interaction.update({ embeds: [embed], components: [] });
    } else {
      const nextNumber = Math.floor(Math.random() * 100) + 1;
      const correct = (action === 'higher' && nextNumber > game.currentNumber) ||
                     (action === 'lower' && nextNumber < game.currentNumber);

      if (correct) {
        game.streak++;
        game.currentNumber = nextNumber;

        const multipliers = [0, 2, 3, 5, 7, 10];
        const multiplier = multipliers[Math.min(game.streak, 5)];

        const streakEmojis = ['', '‚ú®', '‚≠ê', 'üåü', 'üí´', 'üíé'];
        const streakText = game.streak >= 5 ? 'üíé **¬°RACHA √âPICA!** üíé' : game.streak >= 3 ? 'üåü **¬°GRAN RACHA!** üåü' : '‚ú® **¬°Correcto!** ‚ú®';

        const embed = new EmbedBuilder()
          .setColor(game.streak >= 5 ? '#f1c40f' : game.streak >= 3 ? '#9b59b6' : '#3498db')
          .setTitle('üìä Higher or Lower - ¬°Acertaste!')
          .setDescription(`‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë                                          ‚ïë\n‚ïë   ${streakText}   ‚ïë\n‚ïë                                          ‚ïë\n‚ïë      üé≤ Nuevo n√∫mero:      ‚ïë\n‚ïë         **${nextNumber}**         ‚ïë\n‚ïë                                          ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n‚ùì **¬øSeguir jugando o cobrar?**`)
          .addFields(
            { name: 'üí∞ Apuesta', value: `**${game.bet.toLocaleString()}** ü™ô`, inline: true },
            { name: 'üî• Racha', value: `**${game.streak}** ${streakEmojis[Math.min(game.streak, 5)]}`, inline: true },
            { name: 'üíé Multiplicador', value: `**${multiplier}x**`, inline: true }
          )
          .setFooter({ text: `üí° Ganancia actual: ${((game.bet * multiplier) - game.bet).toLocaleString()} ü™ô` });

        const buttons = new ActionRowBuilder().addComponents(
          new ButtonBuilder()
            .setCustomId(`hl_higher_${gameId}`)
            .setLabel('‚¨ÜÔ∏è Mayor')
            .setStyle(ButtonStyle.Success),
          new ButtonBuilder()
            .setCustomId(`hl_lower_${gameId}`)
            .setLabel('‚¨áÔ∏è Menor')
            .setStyle(ButtonStyle.Danger),
          new ButtonBuilder()
            .setCustomId(`hl_cashout_${gameId}`)
            .setLabel('üí∞ Cobrar')
            .setStyle(ButtonStyle.Primary)
            .setDisabled(game.streak === 0)
        );

        await interaction.update({ embeds: [embed], components: [buttons] });
      } else {
        const userData = getUser(interaction.user.id);
        userData.coins -= game.bet;
        userData.stats.gamesPlayed++;
        userData.stats.gamesLost++;
        userData.stats.totalLosses += game.bet;
        updateUser(interaction.user.id, userData);

        const embed = new EmbedBuilder()
          .setColor('#e74c3c')
          .setTitle('üìä Higher or Lower - ¬°Fallaste!')
          .setDescription(`‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë                                      ‚ïë\n‚ïë   üíî **INCORRECTO** üíî   ‚ïë\n‚ïë                                      ‚ïë\n‚ïë  El n√∫mero era **${nextNumber}**  ‚ïë\n‚ïë   **-${game.bet.toLocaleString()} ü™ô**   ‚ïë\n‚ïë                                      ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`)
          .addFields(
            { name: 'üî• Racha alcanzada', value: game.streak > 0 ? `**${game.streak}** üéØ` : 'Ninguna üò¢', inline: true },
            { name: 'üí∞ Balance', value: `**${userData.coins.toLocaleString()}** ü™ô`, inline: true }
          )
          .setFooter({ text: '¬°No te rindas! Intenta de nuevo' });

        activeGames.delete(gameId);
        await interaction.update({ embeds: [embed], components: [] });
      }
    }
  }
  // ========== SISTEMA DE DUELOS ==========
  if (interaction.isChatInputCommand() && interaction.commandName === 'duel') {
    const opponent = interaction.options.getUser('oponente');
    const bet = interaction.options.getInteger('apuesta');
    const gameType = interaction.options.getString('juego') || 'coinflip';
    const userData = getUser(interaction.user.id);

    if (opponent.id === interaction.user.id) {
      return interaction.reply({ content: '‚ùå No puedes retarte a ti mismo.', flags: 64 });
    }

    if (opponent.bot) {
      return interaction.reply({ content: '‚ùå No puedes retar a un bot.', flags: 64 });
    }

    if (bet <= 0) {
      return interaction.reply({ content: '‚ùå La apuesta debe ser mayor a 0.', flags: 64 });
    }

    if (userData.coins < bet) {
      return interaction.reply({ content: `‚ùå No tienes suficientes monedas. Tienes: **${userData.coins.toLocaleString()}** ü™ô`, flags: 64 });
    }

    const opponentData = getUser(opponent.id);
    if (opponentData.coins < bet) {
      return interaction.reply({ content: `‚ùå ${opponent.username} no tiene suficientes monedas para este duelo.`, flags: 64 });
    }

    // Verificar si ya hay un duelo pendiente con este usuario
    for (const game of activeGames.values()) {
      if (game.game === 'duel' && (game.challenger === interaction.user.id || game.opponent === opponent.id)) {
        return interaction.reply({ content: '‚ùå Ya hay un duelo pendiente con este usuario.', flags: 64 });
      }
    }

    const gameNames = {
      'coinflip': 'ü™ô Cara o Cruz',
      'dice': 'üé≤ Dados',
      'blackjack': 'üÉè Blackjack',
      'rps': '‚úä Piedra/Papel/Tijera',
      'guess': 'üî¢ Adivinanza'
    };

    const duelId = `duel_${interaction.user.id}_${Date.now()}`;
    activeGames.set(duelId, {
      game: 'duel',
      gameType,
      challenger: interaction.user.id,
      opponent: opponent.id,
      bet,
      timestamp: Date.now()
    });

    const embed = new EmbedBuilder()
      .setColor('#e74c3c')
      .setTitle('‚öîÔ∏è Duelo de Monedas')
      .setDescription(`**${interaction.user}** ha retado a **${opponent}** a un duelo!`)
      .addFields(
        { name: 'üí∞ Apuesta', value: `**${bet.toLocaleString()}** ü™ô`, inline: true },
        { name: 'üéØ Modalidad', value: gameNames[gameType], inline: true },
        { name: '‚è±Ô∏è Tiempo l√≠mite', value: '60 segundos', inline: true }
      )
      .setFooter({ text: 'El retado debe aceptar para comenzar' });

    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId(`duel_accept_${duelId}`)
        .setLabel('‚öîÔ∏è Aceptar Duelo')
        .setStyle(ButtonStyle.Success),
      new ButtonBuilder()
        .setCustomId(`duel_decline_${duelId}`)
        .setLabel('‚ùå Rechazar')
        .setStyle(ButtonStyle.Danger)
    );

    await interaction.reply({ content: `${opponent}`, embeds: [embed], components: [buttons] });

    // Auto-cancelar despu√©s de 60 segundos
    setTimeout(() => {
      if (activeGames.has(duelId)) {
        activeGames.delete(duelId);
      }
    }, 60000);
  }

  // Botones de duelo
  if (interaction.isButton() && interaction.customId.startsWith('duel_')) {
    const parts = interaction.customId.split('_');
    const action = parts[1]; // 'accept' o 'decline'
    const duelId = parts.slice(2).join('_');
    
    const duel = activeGames.get(duelId);
    if (!duel) {
      return interaction.reply({ content: '‚ùå Este duelo ya expir√≥ o fue cancelado.', flags: 64 });
    }

    if (interaction.user.id !== duel.opponent) {
      return interaction.reply({ content: '‚ùå Este duelo no es para ti.', flags: 64 });
    }

    if (action === 'decline') {
      activeGames.delete(duelId);
      await interaction.update({ 
        content: '‚ùå Duelo rechazado', 
        embeds: [], 
        components: [] 
      });
      return;
    }

    if (action === 'accept') {
      // Realizar el duelo
      const challenger = await client.users.fetch(duel.challenger);
      const opponent = await client.users.fetch(duel.opponent);
      
      const challengerData = getUser(duel.challenger);
      const opponentData = getUser(duel.opponent);

      // Verificar que ambos a√∫n tengan monedas
      if (challengerData.coins < duel.bet) {
        activeGames.delete(duelId);
        return interaction.update({ 
          content: `‚ùå ${challenger.username} ya no tiene suficientes monedas.`, 
          embeds: [], 
          components: [] 
        });
      }

      if (opponentData.coins < duel.bet) {
        activeGames.delete(duelId);
        return interaction.update({ 
          content: `‚ùå ${opponent.username} ya no tiene suficientes monedas.`, 
          embeds: [], 
          components: [] 
        });
      }

      const gameType = duel.gameType || 'coinflip';
      let winner, loser, resultDetails;

      // Animaci√≥n inicial
      const loadingEmbed = new EmbedBuilder()
        .setColor('#f39c12')
        .setTitle('‚öîÔ∏è Duelo en Progreso');

      await interaction.update({ embeds: [loadingEmbed], components: [] });

      // Ejecutar el juego seg√∫n el tipo
      if (gameType === 'coinflip') {
        loadingEmbed.setDescription('ü™ô **Lanzando moneda...**');
        await interaction.editReply({ embeds: [loadingEmbed] });
        await new Promise(resolve => setTimeout(resolve, 1000));

        loadingEmbed.setDescription('üí´ **Girando...**').setColor('#e67e22');
        await interaction.editReply({ embeds: [loadingEmbed] });
        await new Promise(resolve => setTimeout(resolve, 1000));

        loadingEmbed.setDescription('‚ú® **Cayendo...**').setColor('#f1c40f');
        await interaction.editReply({ embeds: [loadingEmbed] });
        await new Promise(resolve => setTimeout(resolve, 500));

        winner = Math.random() < 0.5 ? duel.challenger : duel.opponent;
        loser = winner === duel.challenger ? duel.opponent : duel.challenger;
        const result = Math.random() < 0.5 ? 'Cara' : 'Cruz';
        resultDetails = `Resultado: **${result}**`;

      } else if (gameType === 'dice') {
        loadingEmbed.setDescription('üé≤ **Lanzando dados...**');
        await interaction.editReply({ embeds: [loadingEmbed] });
        await new Promise(resolve => setTimeout(resolve, 1500));

        const challengerDice = [Math.floor(Math.random() * 6) + 1, Math.floor(Math.random() * 6) + 1];
        const opponentDice = [Math.floor(Math.random() * 6) + 1, Math.floor(Math.random() * 6) + 1];
        const challengerSum = challengerDice.reduce((a, b) => a + b, 0);
        const opponentSum = opponentDice.reduce((a, b) => a + b, 0);

        loadingEmbed.setDescription(`üé≤ **Resultados:**\n\n${challenger.username}: [${challengerDice[0]}] [${challengerDice[1]}] = **${challengerSum}**\n${opponent.username}: [${opponentDice[0]}] [${opponentDice[1]}] = **${opponentSum}**`);
        await interaction.editReply({ embeds: [loadingEmbed] });
        await new Promise(resolve => setTimeout(resolve, 2000));

        if (challengerSum > opponentSum) {
          winner = duel.challenger;
          loser = duel.opponent;
        } else if (opponentSum > challengerSum) {
          winner = duel.opponent;
          loser = duel.challenger;
        } else {
          // Empate - ganador aleatorio
          winner = Math.random() < 0.5 ? duel.challenger : duel.opponent;
          loser = winner === duel.challenger ? duel.opponent : duel.challenger;
        }
        resultDetails = `${challenger.username}: **${challengerSum}** | ${opponent.username}: **${opponentSum}**`;

      } else if (gameType === 'blackjack') {
        loadingEmbed.setDescription('üÉè **Repartiendo cartas...**');
        await interaction.editReply({ embeds: [loadingEmbed] });
        await new Promise(resolve => setTimeout(resolve, 1500));

        const drawCard = () => Math.min(Math.floor(Math.random() * 13) + 1, 10);
        const calculateScore = (cards) => {
          let score = cards.reduce((a, b) => a + b, 0);
          if (score > 21 && cards.includes(1)) {
            score -= 10;
          }
          return score;
        };

        const challengerCards = [drawCard(), drawCard()];
        const opponentCards = [drawCard(), drawCard()];
        let challengerScore = calculateScore(challengerCards);
        let opponentScore = calculateScore(opponentCards);

        loadingEmbed.setDescription(`üÉè **Cartas iniciales:**\n\n${challenger.username}: **${challengerScore}**\n${opponent.username}: **${opponentScore}**`);
        await interaction.editReply({ embeds: [loadingEmbed] });
        await new Promise(resolve => setTimeout(resolve, 2000));

        if (challengerScore > opponentScore && challengerScore <= 21) {
          winner = duel.challenger;
          loser = duel.opponent;
        } else if (opponentScore > challengerScore && opponentScore <= 21) {
          winner = duel.opponent;
          loser = duel.challenger;
        } else if (challengerScore > 21 && opponentScore <= 21) {
          winner = duel.opponent;
          loser = duel.challenger;
        } else if (opponentScore > 21 && challengerScore <= 21) {
          winner = duel.challenger;
          loser = duel.opponent;
        } else {
          winner = Math.random() < 0.5 ? duel.challenger : duel.opponent;
          loser = winner === duel.challenger ? duel.opponent : duel.challenger;
        }
        resultDetails = `${challenger.username}: **${challengerScore}** | ${opponent.username}: **${opponentScore}**`;

      } else if (gameType === 'rps') {
        loadingEmbed.setDescription('‚úä **Eligiendo jugadas...**');
        await interaction.editReply({ embeds: [loadingEmbed] });
        await new Promise(resolve => setTimeout(resolve, 1500));

        const choices = ['piedra', 'papel', 'tijera'];
        const emojis = { 'piedra': '‚úä', 'papel': '‚úã', 'tijera': '‚úåÔ∏è' };
        const challengerChoice = choices[Math.floor(Math.random() * 3)];
        const opponentChoice = choices[Math.floor(Math.random() * 3)];

        loadingEmbed.setDescription(`‚úä **Jugadas:**\n\n${challenger.username}: ${emojis[challengerChoice]} **${challengerChoice}**\n${opponent.username}: ${emojis[opponentChoice]} **${opponentChoice}**`);
        await interaction.editReply({ embeds: [loadingEmbed] });
        await new Promise(resolve => setTimeout(resolve, 2000));

        if (challengerChoice === opponentChoice) {
          winner = Math.random() < 0.5 ? duel.challenger : duel.opponent;
          loser = winner === duel.challenger ? duel.opponent : duel.challenger;
        } else if (
          (challengerChoice === 'piedra' && opponentChoice === 'tijera') ||
          (challengerChoice === 'papel' && opponentChoice === 'piedra') ||
          (challengerChoice === 'tijera' && opponentChoice === 'papel')
        ) {
          winner = duel.challenger;
          loser = duel.opponent;
        } else {
          winner = duel.opponent;
          loser = duel.challenger;
        }
        resultDetails = `${emojis[challengerChoice]} vs ${emojis[opponentChoice]}`;

      } else if (gameType === 'guess') {
        loadingEmbed.setDescription('üî¢ **Adivinando n√∫mero (1-100)...**');
        await interaction.editReply({ embeds: [loadingEmbed] });
        await new Promise(resolve => setTimeout(resolve, 1500));

        const targetNumber = Math.floor(Math.random() * 100) + 1;
        const challengerGuess = Math.floor(Math.random() * 100) + 1;
        const opponentGuess = Math.floor(Math.random() * 100) + 1;
        const challengerDiff = Math.abs(targetNumber - challengerGuess);
        const opponentDiff = Math.abs(targetNumber - opponentGuess);

        loadingEmbed.setDescription(`üî¢ **N√∫mero secreto: ${targetNumber}**\n\n${challenger.username}: **${challengerGuess}** (diferencia: ${challengerDiff})\n${opponent.username}: **${opponentGuess}** (diferencia: ${opponentDiff})`);
        await interaction.editReply({ embeds: [loadingEmbed] });
        await new Promise(resolve => setTimeout(resolve, 2000));

        if (challengerDiff < opponentDiff) {
          winner = duel.challenger;
          loser = duel.opponent;
        } else if (opponentDiff < challengerDiff) {
          winner = duel.opponent;
          loser = duel.challenger;
        } else {
          winner = Math.random() < 0.5 ? duel.challenger : duel.opponent;
          loser = winner === duel.challenger ? duel.opponent : duel.challenger;
        }
        resultDetails = `N√∫mero: **${targetNumber}** | ${challenger.username}: ${challengerGuess} | ${opponent.username}: ${opponentGuess}`;
      }

      // Actualizar datos de los jugadores
      const winnerData = getUser(winner);
      const loserData = getUser(loser);

      winnerData.coins += duel.bet;
      loserData.coins -= duel.bet;

      winnerData.stats.gamesPlayed++;
      winnerData.stats.gamesWon++;
      winnerData.stats.totalWinnings += duel.bet;

      loserData.stats.gamesPlayed++;
      loserData.stats.gamesLost++;
      loserData.stats.totalLosses += duel.bet;

      updateUser(winner, winnerData);
      updateUser(loser, loserData);

      const winnerUser = winner === duel.challenger ? challenger : opponent;
      const loserUser = loser === duel.challenger ? challenger : opponent;

      const resultEmbed = new EmbedBuilder()
        .setColor('#2ecc71')
        .setTitle('‚öîÔ∏è Resultado del Duelo')
        .setDescription(`‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë                                              ‚ïë\n‚ïë   üèÜ **¬°${winnerUser.username.toUpperCase()} GANA!** üèÜ   ‚ïë\n‚ïë                                              ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n${resultDetails}`)
        .addFields(
          { name: 'üëë Ganador', value: `${winnerUser}\n+${duel.bet.toLocaleString()} ü™ô`, inline: true },
          { name: 'üíî Perdedor', value: `${loserUser}\n-${duel.bet.toLocaleString()} ü™ô`, inline: true },
          { name: '\u200b', value: '\u200b', inline: true },
          { name: 'üí∞ Nuevo balance (Ganador)', value: `${winnerData.coins.toLocaleString()} ü™ô`, inline: true },
          { name: 'üí∞ Nuevo balance (Perdedor)', value: `${loserData.coins.toLocaleString()} ü™ô`, inline: true }
        )
        .setFooter({ text: '¬°Buen duelo! Usa /duel para retar a alguien m√°s' })
        .setTimestamp();

      activeGames.delete(duelId);
      await interaction.editReply({ embeds: [resultEmbed] });
    }
  }

  // ========== TIENDA DE ITEMS ==========
  if (interaction.isChatInputCommand() && interaction.commandName === 'shop') {
    const shopItems = [
      { id: 'lucky_charm', name: 'üçÄ Amuleto de la Suerte', price: 5000, description: '+10% de probabilidad de ganar por 24h' },
      { id: 'shield', name: 'üõ°Ô∏è Escudo Protector', price: 3000, description: 'Protege el 50% de p√©rdidas por 12h' },
      { id: 'multiplier', name: 'üíé Multiplicador x2', price: 10000, description: 'Duplica ganancias por 1 hora' },
      { id: 'daily_boost', name: '‚ö° Boost Diario', price: 2000, description: 'Daily da 500 monedas extra por 7 d√≠as' },
      { id: 'vip_title', name: 'üëë T√≠tulo VIP', price: 15000, description: 'T√≠tulo permanente "VIP" en tu perfil' }
    ];

    const embed = new EmbedBuilder()
      .setColor('#f1c40f')
      .setTitle('üõí Tienda de Items')
      .setDescription('Compra items especiales con tus monedas. Usa `/buy <nombre>` para comprar.\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ')
      .setFooter({ text: `üí∞ Tu balance: ${getUser(interaction.user.id).coins.toLocaleString()} ü™ô` });

    shopItems.forEach(item => {
      embed.addFields({
        name: `${item.name} - ${item.price.toLocaleString()} ü™ô`,
        value: `${item.description}\n\`/buy ${item.id}\``,
        inline: false
      });
    });

    await interaction.reply({ embeds: [embed] });
  }

  if (interaction.isChatInputCommand() && interaction.commandName === 'buy') {
    const itemId = interaction.options.getString('item');
    const userData = getUser(interaction.user.id);

    const shopItems = {
      'lucky_charm': { name: 'üçÄ Amuleto de la Suerte', price: 5000, duration: 86400000 },
      'shield': { name: 'üõ°Ô∏è Escudo Protector', price: 3000, duration: 43200000 },
      'multiplier': { name: 'üíé Multiplicador x2', price: 10000, duration: 3600000 },
      'daily_boost': { name: '‚ö° Boost Diario', price: 2000, duration: 604800000 },
      'vip_title': { name: 'üëë T√≠tulo VIP', price: 15000, duration: null }
    };

    const item = shopItems[itemId];
    if (!item) {
      return interaction.reply({ content: '‚ùå Item no encontrado. Usa `/shop` para ver items disponibles.', flags: 64 });
    }

    if (userData.coins < item.price) {
      return interaction.reply({ 
        content: `‚ùå No tienes suficientes monedas.\nüí∞ Precio: **${item.price.toLocaleString()}** ü™ô\nüí∞ Tienes: **${userData.coins.toLocaleString()}** ü™ô`, 
        flags: 64 
      });
    }

    // Verificar si ya tiene el item
    const existingItem = userData.inventory.find(i => i.id === itemId && i.expires > Date.now());
    if (existingItem) {
      return interaction.reply({ content: `‚ùå Ya tienes **${item.name}** activo.`, flags: 64 });
    }

    userData.coins -= item.price;
    
    if (itemId === 'vip_title') {
      if (!userData.titles.includes('üëë VIP')) {
        userData.titles.push('üëë VIP');
      }
    } else {
      userData.inventory.push({
        id: itemId,
        name: item.name,
        purchasedAt: Date.now(),
        expires: Date.now() + item.duration
      });
    }

    updateUser(interaction.user.id, userData);

    const embed = new EmbedBuilder()
      .setColor('#2ecc71')
      .setTitle('‚úÖ Compra Exitosa')
      .setDescription(`Has comprado **${item.name}**`)
      .addFields(
        { name: 'üí∞ Precio', value: `${item.price.toLocaleString()} ü™ô`, inline: true },
        { name: 'üíµ Nuevo balance', value: `${userData.coins.toLocaleString()} ü™ô`, inline: true }
      )
      .setTimestamp();

    await interaction.reply({ embeds: [embed] });
  }

  if (interaction.isChatInputCommand() && interaction.commandName === 'inventory') {
    const targetUser = interaction.options.getUser('usuario') || interaction.user;
    const userData = getUser(targetUser.id);

    const activeItems = userData.inventory.filter(item => item.expires > Date.now());

    const embed = new EmbedBuilder()
      .setColor('#9b59b6')
      .setTitle(`üéí Inventario de ${targetUser.username}`)
      .setDescription(activeItems.length > 0 ? 'Items activos:' : 'No tienes items activos.')
      .setTimestamp();

    if (activeItems.length > 0) {
      activeItems.forEach(item => {
        const timeLeft = Math.floor((item.expires - Date.now()) / 1000 / 60);
        embed.addFields({
          name: item.name,
          value: `‚è±Ô∏è Expira en: ${timeLeft} minutos`,
          inline: true
        });
      });
    }

    if (userData.titles.length > 0) {
      embed.addFields({
        name: 'üèÜ T√≠tulos',
        value: userData.titles.join(', '),
        inline: false
      });
    }

    await interaction.reply({ embeds: [embed] });
  }

  // ========== GU√çA PARA USUARIOS ==========
  if (interaction.isChatInputCommand() && interaction.commandName === 'guia-usuarios') {
    await interaction.reply('üìñ **Enviando gu√≠a completa de comandos para usuarios...**');

    // Embed 1: Tickets
    const embed1 = new EmbedBuilder()
      .setColor('#2ecc71')
      .setTitle('üé´ Sistema de Tickets')
      .addFields(
        { name: 'üìù Crear Ticket de Reclutamiento', value: 'Click en "üìù Postularme" en el panel\n**Info:** Nombre, Edad, Activision ID, Rol/KD, Disponibilidad, Presentaci√≥n\n**L√≠mite:** 1 ticket por usuario', inline: false },
        { name: 'üêõ Crear Ticket de Soporte', value: '**Reporte de Bug** o **Duda/Consulta**\n‚ö†Ô∏è Auto-cierre a las 48h sin respuesta tuya', inline: false }
      );

    // Embed 2: Econom√≠a B√°sica
    const embed2 = new EmbedBuilder()
      .setColor('#f1c40f')
      .setTitle('üí∞ Econom√≠a B√°sica')
      .addFields(
        { name: '`/balance [@usuario]`', value: 'Ver monedas, banco, inventario y estad√≠sticas de juegos', inline: false },
        { name: '`/daily`', value: '**Recompensa:** 100 ü™ô\n**Cooldown:** 24 horas', inline: true },
        { name: '`/leaderboard`', value: 'Top 10 usuarios m√°s ricos', inline: true },
        { name: '`/give @usuario cantidad`', value: '**Comisi√≥n:** 5%\nEj: Enviar 1000 = cobran 1050', inline: false }
      );

    // Embed 3: Econom√≠a Avanzada
    const embed3 = new EmbedBuilder()
      .setColor('#e67e22')
      .setTitle('üíº Econom√≠a Avanzada')
      .addFields(
        { name: '`/work`', value: '**Ganancias:** 50-280 ü™ô\n**Trabajos:** Programador, Chef, Conductor, Profesor, M√©dico, Streamer\n**Cooldown:** 1 hora', inline: false },
        { name: '`/bank accion`', value: '**Ver Balance** - Tu dinero total\n**Depositar** - Guardar seguro\n**Retirar** - Sacar del banco', inline: false },
        { name: '`/loan accion`', value: '**Pedir:** 100-5,000 ü™ô (10% inter√©s, 7 d√≠as)\n**Ver estado** - Tu pr√©stamo activo\n**Pagar** - Saldar deuda completa', inline: false }
      );

    // Embed 4: Juegos Casino (parte 1)
    const embed4 = new EmbedBuilder()
      .setColor('#9b59b6')
      .setTitle('üéÆ Juegos de Casino (Parte 1)')
      .addFields(
        { name: 'ü™ô `/coinflip apuesta eleccion`', value: 'Cara o Cruz. **Premio:** x2', inline: true },
        { name: 'üé≤ `/dice apuesta`', value: 'Lanza 2 dados\n**Jackpot (12):** x5\n**10-11:** x2', inline: true },
        { name: 'üÉè `/blackjack apuesta`', value: 'Llega a 21\n**Blackjack:** x2.5\n**Ganar:** x2', inline: true },
        { name: 'üé∞ `/roulette apuesta eleccion`', value: 'Rojo/Negro/Verde\n**Verde (0):** x14\n**Rojo/Negro:** x2', inline: true }
      );

    // Embed 5: Juegos Casino (parte 2)
    const embed5 = new EmbedBuilder()
      .setColor('#9b59b6')
      .setTitle('üéÆ Juegos de Casino (Parte 2)')
      .addFields(
        { name: '‚úä `/rps apuesta eleccion`', value: 'Piedra, Papel o Tijera\n**Ganar:** x2\n**Empate:** Recuperas apuesta', inline: false },
        { name: 'üî¢ `/guess apuesta`', value: 'Adivina n√∫mero 1-100 (5 intentos)\n**1er intento:** x5\n**2do:** x4\n**3er:** x3\n**4to:** x2\n**5to:** x1', inline: false },
        { name: 'üìä `/higher-lower apuesta`', value: 'Mayor o Menor\n**Racha:** Cada acierto = x1 m√°s\nPuedes retirarte en cualquier momento', inline: false }
      );

    // Embed 6: Duelos
    const embed6 = new EmbedBuilder()
      .setColor('#e74c3c')
      .setTitle('‚öîÔ∏è Sistema de Duelos')
      .setDescription('**Comando:** `/duel @oponente apuesta [juego]`')
      .addFields(
        { name: 'ü™ô Coinflip', value: 'Moneda al azar (por defecto)', inline: true },
        { name: 'üé≤ Dados', value: 'Lanza 2 dados, mayor suma gana', inline: true },
        { name: 'üÉè Blackjack', value: '2 cartas, m√°s cerca de 21', inline: true },
        { name: '‚úä RPS', value: 'Piedra/Papel/Tijera', inline: true },
        { name: 'üî¢ Adivinanza', value: 'M√°s cerca del n√∫mero gana', inline: true },
        { name: 'üìã Funcionamiento', value: '1Ô∏è‚É£ Retas oponente\n2Ô∏è‚É£ 60s para aceptar\n3Ô∏è‚É£ Juego autom√°tico\n4Ô∏è‚É£ Ganador se lleva todo', inline: false }
      );

    // Embed 7: Tienda
    const embed7 = new EmbedBuilder()
      .setColor('#1abc9c')
      .setTitle('üõí Tienda e Inventario')
      .addFields(
        { name: '`/shop`', value: 'Ver todos los items disponibles para comprar', inline: false },
        { name: '`/buy item:<nombre>`', value: 'üçÄ **Amuleto de la Suerte** - 5,000 ü™ô\nüõ°Ô∏è **Escudo Protector** - 3,000 ü™ô\nüíé **Multiplicador x2** - 10,000 ü™ô\n‚ö° **Boost Diario** - 2,000 ü™ô\nüëë **T√≠tulo VIP** - 15,000 ü™ô', inline: false },
        { name: '`/inventory [@usuario]`', value: 'Ver tu inventario o el de otro usuario', inline: false }
      );

    // Embed 8: Entretenimiento
    const embed8 = new EmbedBuilder()
      .setColor('#f39c12')
      .setTitle('üéØ Entretenimiento')
      .addFields(
        { name: '`/daily-quest`', value: '**3 misiones diarias** aleatorias\n**Recompensas:** 80-200 ü™ô cada una\n**Ejemplos:** Juega 3 partidas, Gana 2 juegos, Trabaja 2 veces\n‚è∞ Se renuevan cada 24h', inline: false },
        { name: '`/spin`', value: '**Ruleta de premios gratis**\nüé∞ 1 spin cada 24h\nüí∞ Premios: 50-1,000 ü™ô o items\n**Probabilidades:**\n50ü™ô (30%), 100ü™ô (25%), 250ü™ô (20%)\n500ü™ô (15%), 1000ü™ô (7%), Item (3%)', inline: false },
        { name: '`/streak`', value: '**Racha de d√≠as consecutivos**\nüî• 3 d√≠as = +50 ü™ô\n‚ö° 7 d√≠as = +100 ü™ô\nüí´ 14 d√≠as = +250 ü™ô\nüëë 30 d√≠as = +500 ü™ô\n‚ö†Ô∏è Se reinicia si faltas un d√≠a', inline: false }
      );

    // Embed 9: Tips
    const embed9 = new EmbedBuilder()
      .setColor('#3498db')
      .setTitle('üí° Tips y Consejos')
      .addFields(
        { name: 'üìà Para Ganar Monedas', value: '‚úÖ `/daily` todos los d√≠as\n‚úÖ `/work` cada hora\n‚úÖ Mant√©n tu racha activa\n‚úÖ Completa misiones diarias\n‚úÖ `/spin` gratis diario', inline: true },
        { name: 'üí∞ Para Maximizar', value: 'üè¶ Guarda en el banco\nüìä Pr√©stamos para inversi√≥n\nüõí Compra items estrat√©gicos\n‚öîÔ∏è Duelos cuando tengas ventaja\nüé≤ Apuestas bajas al inicio', inline: true }
      )
      .setFooter({ text: 'Usa /guia-staff para ver comandos de staff' });

    // Enviar todos los embeds
    await interaction.channel.send({ embeds: [embed1] });
    await interaction.channel.send({ embeds: [embed2] });
    await interaction.channel.send({ embeds: [embed3] });
    await interaction.channel.send({ embeds: [embed4] });
    await interaction.channel.send({ embeds: [embed5] });
    await interaction.channel.send({ embeds: [embed6] });
    await interaction.channel.send({ embeds: [embed7] });
    await interaction.channel.send({ embeds: [embed8] });
    await interaction.channel.send({ embeds: [embed9] });
  }

  // ========== GU√çA PARA STAFF ==========
  if (interaction.isChatInputCommand() && interaction.commandName === 'guia-staff') {
    const staffRoleIds = getStaffRoles();
    const hasStaffRole = interaction.member.roles.cache.some(role => staffRoleIds.includes(role.id));
    
    if (!hasStaffRole && !interaction.member.permissions.has(PermissionFlagsBits.Administrator)) {
      return interaction.reply({ content: '‚ùå Este comando es solo para el Staff.', flags: 64 });
    }

    await interaction.reply('üë®‚Äçüíº **Enviando gu√≠a completa de comandos para staff...**');

    // Embed 1: Gesti√≥n de Tickets
    const embedS1 = new EmbedBuilder()
      .setColor('#95a5a6')
      .setTitle('üé´ Gesti√≥n de Tickets')
      .addFields(
        { name: '`/panel-reclutamiento`', value: 'üîí **Admin only**\nCrea el panel de reclutamiento con bot√≥n de postulaci√≥n', inline: false },
        { name: '`/panel-soporte`', value: 'üîí **Admin only**\nCrea el panel de soporte con botones de Bug y Dudas', inline: false },
        { name: 'Bot√≥n "‚úã Reclamar"', value: 'Aparece en cada ticket nuevo\nReclama el ticket para atenderlo\nMuestra tu nombre en el ticket', inline: true },
        { name: 'Bot√≥n "üîí Cerrar"', value: 'Cierra el ticket actual\nEnv√≠a log al canal de logs\nElimina el canal en 5 segundos', inline: true },
        { name: '‚è∞ Auto-cierre', value: 'Los tickets se cierran autom√°ticamente si el usuario no responde en 48 horas\nSe env√≠a aviso 30 segundos antes', inline: false }
      );

    // Embed 2: Templates de Respuestas
    const embedS2 = new EmbedBuilder()
      .setColor('#3498db')
      .setTitle('üìù Templates de Respuestas')
      .setDescription('**Comando:** `/respuesta template:<tipo>`')
      .addFields(
        { name: 'üëã Bienvenida', value: 'Saludo inicial al abrir ticket', inline: true },
        { name: 'üîç En revisi√≥n', value: 'Ticket siendo revisado', inline: true },
        { name: 'üì∏ Necesita pruebas', value: 'Pedir evidencias adicionales', inline: true },
        { name: '‚úÖ Resuelto', value: 'Problema solucionado', inline: true },
        { name: '‚ùå Rechazado', value: 'Solicitud rechazada', inline: true },
        { name: '‚è±Ô∏è En espera', value: 'Esperando respuesta del usuario', inline: true },
        { name: 'üîí Cerrar ticket', value: 'Mensaje de cierre', inline: true }
      )
      .setFooter({ text: 'Usa estos templates para ahorrar tiempo' });

    // Embed 3: Gesti√≥n de Econom√≠a
    const embedS3 = new EmbedBuilder()
      .setColor('#f1c40f')
      .setTitle('üí∞ Gesti√≥n de Econom√≠a')
      .addFields(
        { name: '`/add-coins @usuario cantidad`', value: '**Funci√≥n:** Agregar monedas a un usuario\n**Uso:** Recompensas, compensaciones, eventos especiales\n**Log:** El usuario recibe notificaci√≥n', inline: false },
        { name: '`/remove-coins @usuario cantidad`', value: '**Funci√≥n:** Quitar monedas a un usuario\n**Uso:** Sanciones, correcciones de bugs\n**Log:** El usuario recibe notificaci√≥n', inline: false },
        { name: 'üí° Buenas Pr√°cticas', value: '‚Ä¢ Usa add-coins para premiar buen comportamiento\n‚Ä¢ Documenta las razones de cambios econ√≥micos\n‚Ä¢ Revisa el balance antes de quitar monedas\n‚Ä¢ S√© justo y consistente', inline: false }
      );

    // Embed 4: Sistema de Logs
    const embedS4 = new EmbedBuilder()
      .setColor('#e67e22')
      .setTitle('üìä Sistema de Logs')
      .addFields(
        { name: 'üîî Logs Autom√°ticos', value: 'Todos los eventos importantes se registran en el canal de logs configurado', inline: false },
        { name: 'üìù Qu√© se Registra', value: '‚Ä¢ Apertura de tickets\n‚Ä¢ Cierre de tickets (manual y autom√°tico)\n‚Ä¢ Qui√©n reclam√≥ cada ticket\n‚Ä¢ Tiempo de duraci√≥n\n‚Ä¢ Modificaciones de econom√≠a por staff', inline: false },
        { name: 'üîç Revisar Logs', value: 'Revisa el canal de logs regularmente para:\n‚Ä¢ Monitorear actividad del servidor\n‚Ä¢ Detectar problemas recurrentes\n‚Ä¢ Evaluar desempe√±o del equipo', inline: false }
      );

    // Embed 5: Tips para Staff
    const embedS5 = new EmbedBuilder()
      .setColor('#2ecc71')
      .setTitle('‚ú® Tips para Staff')
      .addFields(
        { name: 'üéØ Eficiencia', value: '‚Ä¢ Reclama tickets r√°pidamente\n‚Ä¢ Usa `/respuesta` para respuestas comunes\n‚Ä¢ Mant√©n comunicaci√≥n clara con el usuario\n‚Ä¢ Cierra tickets cuando est√©n resueltos', inline: false },
        { name: '‚ö†Ô∏è Importante', value: '‚Ä¢ Responde dentro de las 48h para evitar auto-cierre\n‚Ä¢ S√© profesional y respetuoso siempre\n‚Ä¢ No abuses de los comandos de econom√≠a\n‚Ä¢ Documenta decisiones importantes', inline: false },
        { name: 'üìã Recordatorios', value: '‚Ä¢ Los tickets de reclutamiento requieren evidencias\n‚Ä¢ Verifica identidad antes de dar informaci√≥n sensible\n‚Ä¢ Mant√©n los tickets organizados\n‚Ä¢ Consulta con otros staff si tienes dudas', inline: false }
      )
      .setFooter({ text: 'Gracias por ser parte del equipo ‚ù§Ô∏è' });

    // Enviar todos los embeds de staff
    await interaction.channel.send({ embeds: [embedS1] });
    await interaction.channel.send({ embeds: [embedS2] });
    await interaction.channel.send({ embeds: [embedS3] });
    await interaction.channel.send({ embeds: [embedS4] });
    await interaction.channel.send({ embeds: [embedS5] });
  }

  // ========== TEMPLATES DE RESPUESTAS (STAFF) ==========
  if (interaction.isChatInputCommand() && interaction.commandName === 'respuesta') {
    const staffRoleIds = getStaffRoles();
    const hasStaffRole = interaction.member.roles.cache.some(role => staffRoleIds.includes(role.id));
    
    if (!hasStaffRole && !interaction.member.permissions.has(PermissionFlagsBits.Administrator)) {
      return interaction.reply({ content: '‚ùå Este comando es solo para el Staff.', flags: 64 });
    }

    const template = interaction.options.getString('template');
    
    const templates = {
      'bienvenida': '¬°Hola! Gracias por contactarnos. Un miembro del staff te atender√° pronto. Por favor, describe tu problema o consulta con el mayor detalle posible.',
      'en_revision': 'Estamos revisando tu caso. Te responderemos lo antes posible con una soluci√≥n.',
      'necesita_pruebas': 'Para continuar con tu solicitud, necesitamos que proporciones pruebas (capturas de pantalla, videos, etc.). Por favor, s√∫belas en este canal.',
      'resuelto': '‚úÖ Tu caso ha sido resuelto. Si tienes alguna otra consulta, no dudes en abrir otro ticket. ¬°Gracias!',
      'rechazado': '‚ùå Lamentablemente tu solicitud ha sido rechazada. Si tienes dudas sobre esta decisi√≥n, puedes contactar con un administrador.',
      'espera': 'Actualmente estamos experimentando un alto volumen de tickets. Agradecemos tu paciencia, te atenderemos lo antes posible.',
      'cierre': 'Vamos a proceder a cerrar este ticket. Si necesitas algo m√°s, puedes abrir uno nuevo. ¬°Gracias por tu comprensi√≥n!'
    };

    const response = templates[template];
    if (!response) {
      return interaction.reply({ content: '‚ùå Template no encontrado.', flags: 64 });
    }

    await interaction.reply({ content: response });
  }
});

client.login(process.env.DISCORD_TOKEN);
